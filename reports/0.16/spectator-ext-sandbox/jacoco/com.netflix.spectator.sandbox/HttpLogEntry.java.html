<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>HttpLogEntry.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spectator-ext-sandbox</a> &gt; <a href="index.source.html" class="el_package">com.netflix.spectator.sandbox</a> &gt; <span class="el_source">HttpLogEntry.java</span></div><h1>HttpLogEntry.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2014 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.netflix.spectator.sandbox;

import com.netflix.spectator.api.ExtendedRegistry;
import com.netflix.spectator.api.Id;
import com.netflix.spectator.api.Spectator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.net.URI;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

/**
 * Helper for logging http request related information.
 */
<span class="nc" id="L38">public class HttpLogEntry {</span>

<span class="nc" id="L40">  private static final Logger LOGGER = LoggerFactory.getLogger(HttpLogEntry.class);</span>

<span class="nc" id="L42">  private static final Marker CLIENT = MarkerFactory.getMarker(&quot;http-client&quot;);</span>
<span class="nc" id="L43">  private static final Marker SERVER = MarkerFactory.getMarker(&quot;http-server&quot;);</span>

<span class="nc" id="L45">  private static final ExtendedRegistry REGISTRY = Spectator.registry();</span>
<span class="nc" id="L46">  private static final Id COMPLETE = REGISTRY.createId(&quot;http.req.complete&quot;);</span>
<span class="nc" id="L47">  private static final Id ATTEMPT = REGISTRY.createId(&quot;http.req.attempt&quot;);</span>
<span class="nc" id="L48">  private static final Id REQ_HEADER_SIZE = REGISTRY.createId(&quot;http.req.headerSize&quot;);</span>
<span class="nc" id="L49">  private static final Id REQ_ENTITY_SIZE = REGISTRY.createId(&quot;http.req.entitySize&quot;);</span>
<span class="nc" id="L50">  private static final Id RES_HEADER_SIZE = REGISTRY.createId(&quot;http.res.headerSize&quot;);</span>
<span class="nc" id="L51">  private static final Id RES_ENTITY_SIZE = REGISTRY.createId(&quot;http.res.entitySize&quot;);</span>

  /**
   * Including the endpoint is useful, but we need to be careful about the number of
   * matches. A fixed prefix list is fairly easy to use and makes the number and set of matches
   * explicit.
   */
<span class="nc" id="L58">  private static final List&lt;String&gt; ENDPOINT_PREFIXES =</span>
<span class="nc" id="L59">      parseEndpoints(Spectator.config().get(&quot;spectator.http.endpointPrefixes&quot;, &quot;/healthcheck&quot;));</span>

  private static List&lt;String&gt; parseEndpoints(String s) {
<span class="nc bnc" id="L62" title="All 2 branches missed.">    String[] prefixes = (s == null) ? new String[] {} : s.split(&quot;[,\\s]+&quot;);</span>
<span class="nc" id="L63">    List&lt;String&gt; buf = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L64" title="All 2 branches missed.">    for (String prefix : prefixes) {</span>
<span class="nc" id="L65">      String tmp = prefix.trim();</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">      if (tmp.length() &gt; 0) {</span>
<span class="nc" id="L67">        buf.add(prefix);</span>
      }
    }
<span class="nc" id="L70">    Collections.sort(buf);</span>
<span class="nc" id="L71">    return buf;</span>
  }

  private static String longestPrefixMatch(String path, String dflt) {
<span class="nc bnc" id="L75" title="All 4 branches missed.">    if (path == null || path.length() == 0) {</span>
<span class="nc" id="L76">      return dflt;</span>
    }

<span class="nc" id="L79">    int length = 0;</span>
<span class="nc" id="L80">    String longest = null;</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">    for (String prefix : ENDPOINT_PREFIXES) {</span>
<span class="nc bnc" id="L82" title="All 4 branches missed.">      if (path.startsWith(prefix) &amp;&amp; prefix.length() &gt; length) {</span>
<span class="nc" id="L83">        longest = prefix;</span>
<span class="nc" id="L84">        length = prefix.length();</span>
      }
<span class="nc" id="L86">    }</span>

<span class="nc bnc" id="L88" title="All 2 branches missed.">    return (longest == null) ? dflt : longest;</span>
  }

  /** Log a client request. */
  public static void logClientRequest(HttpLogEntry entry) {
<span class="nc" id="L93">    log(LOGGER, CLIENT, entry);</span>
<span class="nc" id="L94">  }</span>

  /** Log a client request. */
  public static void logClientRequest(Logger logger, HttpLogEntry entry) {
<span class="nc" id="L98">    log(logger, CLIENT, entry);</span>
<span class="nc" id="L99">  }</span>

  /** Log a request received by a server. */
  public static void logServerRequest(HttpLogEntry entry) {
<span class="nc" id="L103">    log(LOGGER, SERVER, entry);</span>
<span class="nc" id="L104">  }</span>

  /** Log a request received by a server. */
  public static void logServerRequest(Logger logger, HttpLogEntry entry) {
<span class="nc" id="L108">    log(logger, SERVER, entry);</span>
<span class="nc" id="L109">  }</span>

  private static void log(Logger logger, Marker marker, HttpLogEntry entry) {
<span class="nc" id="L112">    Id dimensions = REGISTRY.createId(&quot;tags&quot;)</span>
<span class="nc" id="L113">        .withTag(&quot;mode&quot;, marker.getName())</span>
<span class="nc" id="L114">        .withTag(&quot;status&quot;, entry.getStatusTag())</span>
<span class="nc" id="L115">        .withTag(&quot;statusCode&quot;, entry.getStatusCodeTag())</span>
<span class="nc" id="L116">        .withTag(&quot;method&quot;, entry.method);</span>

<span class="nc bnc" id="L118" title="All 2 branches missed.">    if (entry.clientName != null) {</span>
<span class="nc" id="L119">      dimensions = dimensions.withTag(&quot;client&quot;, entry.clientName);</span>
    }

<span class="nc bnc" id="L122" title="All 4 branches missed.">    if (marker == SERVER &amp;&amp; entry.requestUri != null) {</span>
<span class="nc" id="L123">      String path = entry.requestUri.getPath();</span>
<span class="nc" id="L124">      dimensions = dimensions.withTag(&quot;endpoint&quot;, longestPrefixMatch(path, &quot;other&quot;));</span>
    }

    // Update stats for the final attempt after retries are exhausted
<span class="nc bnc" id="L128" title="All 4 branches missed.">    if (!entry.canRetry || entry.attempt &gt;= entry.maxAttempts) {</span>
<span class="nc" id="L129">      REGISTRY.timer(COMPLETE.withTags(dimensions.tags()))</span>
<span class="nc" id="L130">          .record(entry.getOverallLatency(), TimeUnit.MILLISECONDS);</span>
    }

    // Update stats for every actual http request
<span class="nc" id="L134">    REGISTRY.timer(ATTEMPT.withTags(dimensions.tags()))</span>
<span class="nc" id="L135">        .record(entry.getLatency(), TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L136">    REGISTRY.distributionSummary(REQ_HEADER_SIZE.withTags(dimensions.tags()))</span>
<span class="nc" id="L137">        .record(entry.getRequestHeadersLength());</span>
<span class="nc" id="L138">    REGISTRY.distributionSummary(REQ_ENTITY_SIZE.withTags(dimensions.tags()))</span>
<span class="nc" id="L139">        .record(entry.requestContentLength);</span>
<span class="nc" id="L140">    REGISTRY.distributionSummary(RES_HEADER_SIZE.withTags(dimensions.tags()))</span>
<span class="nc" id="L141">        .record(entry.getResponseHeadersLength());</span>
<span class="nc" id="L142">    REGISTRY.distributionSummary(RES_ENTITY_SIZE.withTags(dimensions.tags()))</span>
<span class="nc" id="L143">        .record(entry.responseContentLength);</span>

    // Write data out to logger if enabled. For many monitoring use-cases there tend to be
    // frequent requests that can be quite noisy so the log level is set to debug. This class is
    // mostly intended to generate something like an access log so it presumes users who want the
    // information will configure an appender based on the markers to send the data to a
    // dedicated file. Others shouldn't have to deal with the spam in the logs, so debug for the
    // level seems reasonable.
<span class="nc bnc" id="L151" title="All 2 branches missed.">    if (logger.isDebugEnabled(marker)) {</span>
<span class="nc" id="L152">      logger.debug(marker, entry.toString());</span>
    }
<span class="nc" id="L154">  }</span>

  /** Generate a new request id. */
  private static String newId() {
<span class="nc" id="L158">    return UUID.randomUUID().toString();</span>
  }

  // Cannot be static constant, date format is not thread-safe
<span class="nc" id="L162">  private final SimpleDateFormat isoDate = new SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss&quot;);</span>

<span class="nc" id="L164">  private String clientName = null;</span>

<span class="nc" id="L166">  private String requestId = newId();</span>

<span class="nc" id="L168">  private URI originalUri = null;</span>
<span class="nc" id="L169">  private URI requestUri = null;</span>
<span class="nc" id="L170">  private String method = null;</span>
<span class="nc" id="L171">  private List&lt;Header&gt; requestHeaders = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L172">  private long requestContentLength = -1;</span>

<span class="nc" id="L174">  private String remoteAddr = null;</span>
<span class="nc" id="L175">  private int remotePort = -1;</span>

<span class="nc" id="L177">  private String attemptId = requestId;</span>
<span class="nc" id="L178">  private int attempt = 1;</span>
<span class="nc" id="L179">  private int maxAttempts = -1;</span>
<span class="nc" id="L180">  private boolean canRetry = false;</span>

<span class="nc" id="L182">  private int redirect = 0;</span>

<span class="nc" id="L184">  private Throwable exception = null;</span>

<span class="nc" id="L186">  private int statusCode = -1;</span>
<span class="nc" id="L187">  private String statusReason = null;</span>
<span class="nc" id="L188">  private List&lt;Header&gt; responseHeaders = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L189">  private long responseContentLength = -1;</span>

<span class="nc" id="L191">  private List&lt;Event&gt; events = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L192">  private long latency = -1;</span>
<span class="nc" id="L193">  private long originalStart = -1;</span>

  private void reset(int redir) {
<span class="nc bnc" id="L196" title="All 4 branches missed.">    if (originalStart &lt; 0 &amp;&amp; !events.isEmpty()) {</span>
<span class="nc" id="L197">      originalStart = events.get(0).timestamp();</span>
    }
<span class="nc" id="L199">    requestHeaders.clear();</span>
<span class="nc" id="L200">    requestContentLength = -1;</span>
<span class="nc" id="L201">    remoteAddr = null;</span>
<span class="nc" id="L202">    remotePort = -1;</span>
<span class="nc" id="L203">    redirect = redir;</span>
<span class="nc" id="L204">    exception = null;</span>
<span class="nc" id="L205">    statusCode = -1;</span>
<span class="nc" id="L206">    responseHeaders.clear();</span>
<span class="nc" id="L207">    responseContentLength = -1;</span>
<span class="nc" id="L208">    events.clear();</span>
<span class="nc" id="L209">    latency = -1;</span>
<span class="nc" id="L210">  }</span>

  /** Set the name of the client, often used for clients to identify a particular config. */
  public HttpLogEntry withClientName(String name) {
<span class="nc" id="L214">    this.clientName = name;</span>
<span class="nc" id="L215">    return this;</span>
  }

  /**
   * Set the original uri. In the case of approaches with client-side load balancing this will
   * be some alias indicating the group of hosts. The request uri would indicate a specific host
   * used for an actual network request.
   */
  public HttpLogEntry withOriginalUri(URI uri) {
<span class="nc" id="L224">    this.originalUri = uri;</span>
<span class="nc" id="L225">    return this;</span>
  }

  /** Set the URI for the actual http request. */
  public HttpLogEntry withRequestUri(URI uri) {
<span class="nc" id="L230">    this.requestUri = uri;</span>
<span class="nc" id="L231">    return this;</span>
  }

  /** Set the method for the request. */
  public HttpLogEntry withMethod(String httpMethod) {
<span class="nc" id="L236">    this.method = httpMethod;</span>
<span class="nc" id="L237">    return this;</span>
  }

  /** Add a header that was on the request. */
  public HttpLogEntry withRequestHeader(String name, String value) {
<span class="nc" id="L242">    requestHeaders.add(new Header(name, value));</span>
<span class="nc" id="L243">    return this;</span>
  }

  /** Set the content-length for the request. */
  public HttpLogEntry withRequestContentLength(long size) {
<span class="nc" id="L248">    this.requestContentLength = size;</span>
<span class="nc" id="L249">    return this;</span>
  }

  /**
   * Set the remote address. For a client making a request this should be the server, for a
   * server receiving a request it should be the client.
   */
  public HttpLogEntry withRemoteAddr(String addr) {
<span class="nc" id="L257">    this.remoteAddr = addr;</span>
<span class="nc" id="L258">    return this;</span>
  }

  /**
   * Set the remote port. For a client making a request this should be the server, for a
   * server receiving a request it should be the client.
   */
  public HttpLogEntry withRemotePort(int port) {
<span class="nc" id="L266">    this.remotePort = port;</span>
<span class="nc" id="L267">    return this;</span>
  }

  /** Set the attempt if retries are used, should only be used after the initial request. */
  public HttpLogEntry withAttempt(int n) {
<span class="nc" id="L272">    this.attempt = n;</span>
<span class="nc" id="L273">    this.attemptId = newId();</span>
<span class="nc" id="L274">    reset(0);</span>
<span class="nc" id="L275">    return this;</span>
  }

  /** Set the attempt if redirect occurs, should only be used after the initial request. */
  public HttpLogEntry withRedirect(URI loc) {
<span class="nc" id="L280">    reset(redirect + 1);</span>
<span class="nc" id="L281">    return withRequestUri(loc);</span>
  }

  /** Set the max number of attempts that will be tried. */
  public HttpLogEntry withMaxAttempts(int attempts) {
<span class="nc" id="L286">    this.maxAttempts = attempts;</span>
<span class="nc" id="L287">    return this;</span>
  }

  /** Set to true if the error is one that can be retried. */
  public HttpLogEntry withCanRetry(boolean retry) {
<span class="nc" id="L292">    this.canRetry = retry;</span>
<span class="nc" id="L293">    return this;</span>
  }

  /** Set the exception if there is a failure such as a connect timeout. */
  public HttpLogEntry withException(Throwable t) {
<span class="nc" id="L298">    exception = t;</span>
<span class="nc" id="L299">    return this;</span>
  }

  /** Set the status code from the response. */
  public HttpLogEntry withStatusCode(int code) {
<span class="nc" id="L304">    this.statusCode = code;</span>
<span class="nc" id="L305">    return this;</span>
  }

  /** Set the status reason from the response. */
  public HttpLogEntry withStatusReason(String reason) {
<span class="nc" id="L310">    this.statusReason = reason;</span>
<span class="nc" id="L311">    return this;</span>
  }

  /** Add a header that was on the response. */
  public HttpLogEntry withResponseHeader(String name, String value) {
<span class="nc" id="L316">    responseHeaders.add(new Header(name, value));</span>
<span class="nc" id="L317">    return this;</span>
  }

  /** Set the content-length from the response. */
  public HttpLogEntry withResponseContentLength(long size) {
<span class="nc" id="L322">    this.responseContentLength = size;</span>
<span class="nc" id="L323">    return this;</span>
  }

  /** Set the latency for the request. */
  public HttpLogEntry withRequestLatency(long t) {
<span class="nc" id="L328">    this.latency = t;</span>
<span class="nc" id="L329">    return this;</span>
  }

  /** Mark the time an event occurred. Should include at least the start and end of a request. */
  public HttpLogEntry mark(String name) {
<span class="nc" id="L334">    events.add(new Event(name, System.currentTimeMillis()));</span>
<span class="nc" id="L335">    return this;</span>
  }

  /** Mark the time an event occurred. Should include at least the start and end of a request. */
  public HttpLogEntry mark(String name, long timestamp) {
<span class="nc" id="L340">    events.add(new Event(name, timestamp));</span>
<span class="nc" id="L341">    return this;</span>
  }

  /** Return the request id. */
  public String getRequestId() {
<span class="nc" id="L346">    return requestId;</span>
  }

  /** Return the attempt id. */
  public String getAttemptId() {
<span class="nc" id="L351">    return attemptId;</span>
  }

  /**
   * Return the latency for the request. If not explicitly set it will be calculated from the
   * events.
   */
  public long getLatency() {
<span class="nc bnc" id="L359" title="All 2 branches missed.">    if (latency &gt;= 0L) {</span>
<span class="nc" id="L360">      return latency;</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">    } else if (events.size() &gt;= 2) {</span>
<span class="nc" id="L362">      return events.get(events.size() - 1).timestamp() - events.get(0).timestamp();</span>
    } else {
<span class="nc" id="L364">      return -1;</span>
    }
  }

  /** Return the overall latency for a group of requests including all retries. */
  public long getOverallLatency() {
<span class="nc bnc" id="L370" title="All 4 branches missed.">    if (maxAttempts &lt;= 1 || originalStart &lt; 0) {</span>
<span class="nc" id="L371">      return getLatency();</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">    } else if (events.isEmpty()) {</span>
<span class="nc" id="L373">      return -1;</span>
    } else {
<span class="nc" id="L375">      return events.get(events.size() - 1).timestamp() - originalStart;</span>
    }
  }

  /** Return the starting time for the request. */
  public String getStartTime() {
<span class="nc bnc" id="L381" title="All 2 branches missed.">    return events.isEmpty()</span>
        ? &quot;unknown&quot;
<span class="nc" id="L383">        : isoDate.format(new Date(events.get(0).timestamp()));</span>
  }

  private int getHeadersLength(List&lt;Header&gt; headers) {
<span class="nc" id="L387">    int size = 0;</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">    for (Header h : headers) {</span>
<span class="nc" id="L389">      size += h.numBytes();</span>
<span class="nc" id="L390">    }</span>
<span class="nc" id="L391">    return size;</span>
  }

  /** Return the size in bytes of all request headers. */
  public int getRequestHeadersLength() {
<span class="nc" id="L396">    return getHeadersLength(requestHeaders);</span>
  }

  /** Return the size in bytes of all response headers. */
  public int getResponseHeadersLength() {
<span class="nc" id="L401">    return getHeadersLength(responseHeaders);</span>
  }

  /** Return a time line based on marked events. */
  public String getTimeline() {
<span class="nc" id="L406">    StringBuilder builder = new StringBuilder();</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">    for (Event event : events) {</span>
<span class="nc" id="L408">      builder.append(event.name()).append(&quot;:&quot;).append(event.timestamp()).append(&quot;;&quot;);</span>
<span class="nc" id="L409">    }</span>
<span class="nc" id="L410">    return builder.toString();</span>
  }

  private String getExceptionClass() {
<span class="nc bnc" id="L414" title="All 2 branches missed.">    return (exception == null)</span>
        ? &quot;null&quot;
<span class="nc" id="L416">        : exception.getClass().getName();</span>
  }

  private String getExceptionMessage() {
<span class="nc bnc" id="L420" title="All 2 branches missed.">    return (exception == null)</span>
        ? &quot;null&quot;
<span class="nc" id="L422">        : exception.getMessage();</span>
  }

  private String getHeaders(List&lt;Header&gt; headers) {
<span class="nc" id="L426">    StringBuilder builder = new StringBuilder();</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">    for (Header h : headers) {</span>
<span class="nc" id="L428">      builder.append(h.name()).append(':').append(h.value()).append(';');</span>
<span class="nc" id="L429">    }</span>
<span class="nc" id="L430">    return builder.toString();</span>
  }

  /** Return a summary of all request headers. */
  public String getRequestHeaders() {
<span class="nc" id="L435">    return getHeaders(requestHeaders);</span>
  }

  /** Return a summary of all response headers. */
  public String getResponseHeaders() {
<span class="nc" id="L440">    return getHeaders(responseHeaders);</span>
  }

  private String getStatusTag() {
<span class="nc bnc" id="L444" title="All 2 branches missed.">    return (exception != null)</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">        ? exception.getClass().getSimpleName()</span>
        : (statusCode &gt;= 100 ? (statusCode / 100) + &quot;xx&quot; : &quot;unknown&quot;);
  }

  private String getStatusCodeTag() {
<span class="nc bnc" id="L450" title="All 2 branches missed.">    return (exception != null)</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">        ? exception.getClass().getSimpleName()</span>
        : (statusCode &gt;= 100 ? &quot;&quot; + statusCode : &quot;unknown&quot;);
  }

  @Override public String toString() {
<span class="nc" id="L456">    return new StringBuilder()</span>
<span class="nc" id="L457">        .append(clientName).append('\t')</span>
<span class="nc" id="L458">        .append(getStartTime()).append('\t')</span>
<span class="nc" id="L459">        .append(getLatency()).append('\t')</span>
<span class="nc" id="L460">        .append(getOverallLatency()).append('\t')</span>
<span class="nc" id="L461">        .append(getTimeline()).append('\t')</span>
<span class="nc" id="L462">        .append(method).append('\t')</span>
<span class="nc" id="L463">        .append(originalUri).append('\t')</span>
<span class="nc" id="L464">        .append(requestUri).append('\t')</span>
<span class="nc" id="L465">        .append(remoteAddr).append('\t')</span>
<span class="nc" id="L466">        .append(remotePort).append('\t')</span>
<span class="nc" id="L467">        .append(statusCode).append('\t')</span>
<span class="nc" id="L468">        .append(statusReason).append('\t')</span>
<span class="nc" id="L469">        .append(getExceptionClass()).append('\t')</span>
<span class="nc" id="L470">        .append(getExceptionMessage()).append('\t')</span>
<span class="nc" id="L471">        .append(getRequestHeadersLength()).append('\t')</span>
<span class="nc" id="L472">        .append(requestContentLength).append('\t')</span>
<span class="nc" id="L473">        .append(getResponseHeadersLength()).append('\t')</span>
<span class="nc" id="L474">        .append(responseContentLength).append('\t')</span>
<span class="nc" id="L475">        .append(getRequestHeaders()).append('\t')</span>
<span class="nc" id="L476">        .append(getResponseHeaders()).append('\t')</span>
<span class="nc" id="L477">        .append(redirect).append('\t')</span>
<span class="nc" id="L478">        .append(attempt).append('\t')</span>
<span class="nc" id="L479">        .append(maxAttempts)</span>
<span class="nc" id="L480">        .toString();</span>
  }

  private static class Header {
    private final String name;
    private final String value;

<span class="nc" id="L487">    Header(String name, String value) {</span>
<span class="nc" id="L488">      this.name = name;</span>
<span class="nc" id="L489">      this.value = value;</span>
<span class="nc" id="L490">    }</span>

    String name() {
<span class="nc" id="L493">      return name;</span>
    }

    String value() {
<span class="nc" id="L497">      return value;</span>
    }

    int numBytes() {
<span class="nc" id="L501">      return name.length() + &quot;: &quot;.length() + value.length() + &quot;\n&quot; .length();</span>
    }
  }

<span class="nc" id="L505">  private static class Event {</span>
    private final String name;
    private final long timestamp;

<span class="nc" id="L509">    Event(String name, long timestamp) {</span>
<span class="nc" id="L510">      this.name = name;</span>
<span class="nc" id="L511">      this.timestamp = timestamp;</span>
<span class="nc" id="L512">    }</span>

    String name() {
<span class="nc" id="L515">      return name;</span>
    }

    long timestamp() {
<span class="nc" id="L519">      return timestamp;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>
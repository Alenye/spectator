<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TagList.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spectator-api</a> &gt; <a href="index.source.html" class="el_package">com.netflix.spectator.api</a> &gt; <span class="el_source">TagList.java</span></div><h1>TagList.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.netflix.spectator.api;

import com.netflix.spectator.impl.Preconditions;

import java.util.Comparator;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.TreeMap;

/**
 * A tag list implemented as a singly linked list. The contents of the list are maintained in
 * sorted order by key with no duplicates.
 */
final class TagList implements Iterable&lt;Tag&gt;, Tag {
  /**
   * Utility class for sorting and deduplicating lists of tags.
   */
  private static class TagSorterAndDeduplicator {
<span class="fc" id="L35">    private static final Comparator&lt;String&gt; REVERSE_STRING_COMPARATOR =</span>
        (String left, String right) -&gt; right.compareTo(left);

    /** Map used to sort and deduplicate the presented tags. */
    private final Map&lt;String, Tag&gt; map;

    /**
     * Construct a new instance with no tags in it.
     */
<span class="fc" id="L44">    TagSorterAndDeduplicator() {</span>
<span class="fc" id="L45">      map  = new TreeMap&lt;&gt;(REVERSE_STRING_COMPARATOR);</span>
<span class="fc" id="L46">    }</span>

    /**
     * Adds the specified tag to the collected tags. It will overwrite any existing value
     * associated the key in the specified tag.
     *
     * @param tag
     *     The tag to add to the collection.
     */
    void addTag(Tag tag) {
<span class="fc" id="L56">      map.put(tag.key(), tag);</span>
<span class="fc" id="L57">    }</span>

    /**
     * Adds the tags in the iterable to the collected tags. Any values associated with the tags in
     * the iterable will overwrite any existing values with the same key that are already in the
     * collection.
     *
     * @param tags
     *     The set of tags to add.
     */
    void addTags(Iterable&lt;Tag&gt; tags) {
<span class="fc bfc" id="L68" title="All 2 branches covered.">      for (Tag t : tags) {</span>
<span class="fc" id="L69">        map.put(t.key(), t);</span>
<span class="fc" id="L70">      }</span>
<span class="fc" id="L71">    }</span>

    /**
     * Adds the tags (key, value)-pairs to the collected tags. Any values associated with the tags
     * in the map will overwrite any existing values with the same key that are already in the
     * collection.
     *
     * @param tags
     *     The set of tags to add.
     */
    void addTags(Map&lt;String, String&gt; tags) {
<span class="fc bfc" id="L82" title="All 2 branches covered.">      for (Map.Entry&lt;String, String&gt; t : tags.entrySet()) {</span>
<span class="fc" id="L83">        map.put(t.getKey(), new TagList(t.getKey(), t.getValue()));</span>
<span class="fc" id="L84">      }</span>
<span class="fc" id="L85">    }</span>

    /**
     * Returns the sorted set of tags.
     */
    Iterable&lt;Tag&gt; sortedTags() {
<span class="fc" id="L91">      return map.values();</span>
    }
  }

  private final String key;
  private final String value;
  private final TagList next;
  private final int hc;

  /**
   * Create a new instance with a single pair in the list.
   */
  TagList(String key, String value) {
<span class="fc" id="L104">    this(key, value, EMPTY);</span>
<span class="fc" id="L105">  }</span>

  /**
   * Create a new instance with a new tag prepended to the list {@code next}. Any entries in next
   * should have keys that are lexicographically after the specified key.
   */
<span class="fc" id="L111">  private TagList(String key, String value, TagList next) {</span>
<span class="fc" id="L112">    this.key = Preconditions.checkNotNull(key, &quot;key&quot;);</span>
<span class="fc" id="L113">    this.value = Preconditions.checkNotNull(value, &quot;value&quot;);</span>
<span class="fc" id="L114">    this.next = next;</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">    this.hc = 31 * (key.hashCode() + value.hashCode() + (next == null ? 23 : next.hashCode()));</span>
<span class="fc" id="L116">  }</span>

  @Override public String key() {
<span class="fc" id="L119">    return key;</span>
  }

  @Override public String value() {
<span class="fc" id="L123">    return value;</span>
  }

  @Override public Iterator&lt;Tag&gt; iterator() {
<span class="fc" id="L127">    final TagList root = this;</span>
<span class="fc" id="L128">    return new Iterator&lt;Tag&gt;() {</span>
<span class="fc" id="L129">      private TagList current = root;</span>

      public boolean hasNext() {
<span class="fc bfc" id="L132" title="All 2 branches covered.">        return current != EMPTY;</span>
      }

      public Tag next() {
<span class="fc bfc" id="L136" title="All 2 branches covered.">        if (current == EMPTY) {</span>
<span class="fc" id="L137">          throw new NoSuchElementException();</span>
        }
<span class="fc" id="L139">        Tag tmp = current;</span>
<span class="fc" id="L140">        current = current.next;</span>
<span class="fc" id="L141">        return tmp;</span>
      }

      public void remove() {
<span class="fc" id="L145">        throw new UnsupportedOperationException();</span>
      }
    };
  }

  @Override public boolean equals(Object obj) {
<span class="fc bfc" id="L151" title="All 2 branches covered.">    if (this == obj) return true;</span>
<span class="fc bfc" id="L152" title="All 4 branches covered.">    if (obj == null || !(obj instanceof TagList)) return false;</span>
<span class="fc" id="L153">    TagList other = (TagList) obj;</span>
<span class="fc bfc" id="L154" title="All 8 branches covered.">    return key.equals(other.key) &amp;&amp; value.equals(other.value)</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">      &amp;&amp; (next == other.next || (next != null &amp;&amp; next.equals(other.next)));</span>
  }

  /**
   * This object is immutable and the hash code is precomputed in the constructor. The id object
   * is typically created to lookup a Meter based on dynamic dimensions so we assume that it is
   * highly likely that the hash code method will be called and that it could be in a fairly
   * high volume execution path.
   *
   * {@inheritDoc}
   */
  @Override public int hashCode() {
<span class="fc" id="L167">    return hc;</span>
  }

  @Override
  public String toString() {
<span class="fc" id="L172">    StringBuilder buf = new StringBuilder();</span>
<span class="fc" id="L173">    TagList cur = next;</span>

<span class="fc" id="L175">    buf.append(key).append('=').append(value);</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">    while (cur != null) {</span>
<span class="fc" id="L177">      buf.append(&quot;:&quot;).append(cur.key()).append(&quot;=&quot;).append(cur.value());</span>
<span class="fc" id="L178">      cur = cur.next;</span>
    }
<span class="fc" id="L180">    return buf.toString();</span>
  }

  /**
   * Produces a list with with the specified tag merged with the existing values in this list. If
   * the key of the specified tag matches an existing list entry, then the value of the specified
   * tag will replace the existing value.
   *
   * @param tag
   *     Possibly null tag to merge into the list.
   * @return
   *     A tag list with merged values.
   */
  TagList mergeTag(Tag tag) {
<span class="fc bfc" id="L194" title="All 2 branches covered.">    if (tag == null) {</span>
<span class="fc" id="L195">      return this;</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">    } else if (next == null) {</span>
<span class="fc" id="L197">      int comparison = key.compareTo(tag.key());</span>

<span class="fc bfc" id="L199" title="All 2 branches covered.">      if (comparison == 0) { // Same key, so the specified value replaces the current value.</span>
<span class="fc" id="L200">        return new TagList(tag.key(), tag.value(), EMPTY);</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">      } else if (comparison &lt; 0) { // The key in this list is before the key in the specified list.</span>
<span class="fc" id="L202">        return new TagList(key, value, new TagList(tag.key(), tag.value(), EMPTY));</span>
      } else { // The key in this list is after the key in the specified list.
<span class="fc" id="L204">        return new TagList(tag.key(), tag.value(), this);</span>
      }
    } else {
      // Is it possible to optimize this case so as to reuse the tail of the existing TagList?
<span class="fc" id="L208">      TagSorterAndDeduplicator entries = new TagSorterAndDeduplicator();</span>

<span class="fc" id="L210">      entries.addTags(this);</span>
<span class="fc" id="L211">      entries.addTag(tag);</span>

<span class="fc" id="L213">      return createFromSortedTags(entries.sortedTags());</span>
    }
  }

  /**
   * Produces a list with the tags from this list merged with the tags in the specified list. For
   * any keys present in both lists, the value from the specified list will replace the existing
   * value.
   *
   * @param tags
   *     A set of tags to merge.
   * @return
   *     A tag list with the merged values. Based on the inputs the result may be this, tags, or
   *     a new object.
   */
  TagList mergeList(Iterable&lt;Tag&gt; tags) {
<span class="fc bfc" id="L229" title="All 2 branches covered.">    if (tags == null) {</span>
<span class="fc" id="L230">      return this;</span>
    }

<span class="fc" id="L233">    Iterator&lt;Tag&gt; iter = tags.iterator();</span>

<span class="fc bfc" id="L235" title="All 2 branches covered.">    if (iter.hasNext()) {</span>
<span class="fc" id="L236">      Tag firstTag = iter.next();</span>

<span class="fc bfc" id="L238" title="All 2 branches covered.">      if (iter.hasNext()) {</span>
        // Iterator has multiple entries so we need to sort them and remove any duplicates.
<span class="fc" id="L240">        TagSorterAndDeduplicator entries = new TagSorterAndDeduplicator();</span>

<span class="fc" id="L242">        entries.addTags(this);</span>
<span class="fc" id="L243">        entries.addTags(tags);</span>

<span class="fc" id="L245">        return createFromSortedTags(entries.sortedTags());</span>
      } else {
        // Single entry iterator.
<span class="fc" id="L248">        return mergeTag(firstTag);</span>
      }
    } else {
      // Empty iterator
<span class="fc" id="L252">      return this;</span>
    }
  }

  /**
   * Produces a list with the tags from this list merged with the tags in the specified list. For
   * any keys present in both lists, the value from the specified list will replace the existing
   * value.
   *
   * @param tags
   *     A set of tags to merge.
   * @return
   *     A tag list with the merged values. Based on the inputs the result may be this or a new
   *     object.
   */
  TagList mergeMap(Map&lt;String, String&gt; tags) {
<span class="fc bfc" id="L268" title="All 4 branches covered.">    if (tags == null || tags.isEmpty()) {</span>
<span class="fc" id="L269">      return this;</span>
    }

<span class="fc bfc" id="L272" title="All 2 branches covered.">    if (tags.size() == 1) {</span>
<span class="fc" id="L273">      Map.Entry&lt;String, String&gt; entry = tags.entrySet().iterator().next();</span>

<span class="fc" id="L275">      return mergeTag(new TagList(entry.getKey(), entry.getValue(), EMPTY));</span>
    } else {
        // Iterator has multiple entries so we need to sort them and remove any duplicates.
<span class="fc" id="L278">        TagSorterAndDeduplicator entries = new TagSorterAndDeduplicator();</span>

<span class="fc" id="L280">        entries.addTags(this);</span>
<span class="fc" id="L281">        entries.addTags(tags);</span>

<span class="fc" id="L283">      return createFromSortedTags(entries.sortedTags());</span>
    }
  }

  /**
   * Create a new tag list from the key/value pairs in the iterable.
   *
   * @param tags
   *     Set of key/value pairs.
   * @return
   *     New tag list with a copy of the data.
   */
  static TagList create(Iterable&lt;Tag&gt; tags) {
<span class="pc bpc" id="L296" title="1 of 4 branches missed.">    if (tags == EMPTY || tags instanceof TagList) {</span>
<span class="fc" id="L297">      return (TagList) tags;</span>
    } else {
<span class="fc" id="L299">      Iterator&lt;Tag&gt; iter = tags.iterator();</span>

<span class="fc bfc" id="L301" title="All 2 branches covered.">      if (iter.hasNext()) {</span>
<span class="fc" id="L302">        Tag firstTag = iter.next();</span>

<span class="fc bfc" id="L304" title="All 2 branches covered.">        if (iter.hasNext()) {</span>
          // Iterator has multiple entries so we need to sort them and remove any duplicates.
<span class="fc" id="L306">          TagSorterAndDeduplicator entries = new TagSorterAndDeduplicator();</span>

<span class="fc" id="L308">          entries.addTags(tags);</span>

<span class="fc" id="L310">          return createFromSortedTags(entries.sortedTags());</span>
        } else {
          // Single entry iterator.
<span class="fc" id="L313">          return new TagList(firstTag.key(), firstTag.value(), EMPTY);</span>
        }
      } else {
        // Empty iterator
<span class="fc" id="L317">        return EMPTY;</span>
      }
    }
  }

  /**
   * Create a new tag list from the key/value pairs in the map.
   *
   * @param tags
   *     Set of key/value pairs.
   * @return
   *     New tag list with a copy of the data.
   */
  static TagList create(Map&lt;String, String&gt; tags) {
<span class="fc" id="L331">    TagList head = EMPTY;</span>

<span class="fc bfc" id="L333" title="All 2 branches covered.">    if (tags.size() &gt;= 2) {</span>
<span class="fc" id="L334">      TagSorterAndDeduplicator entries = new TagSorterAndDeduplicator();</span>

<span class="fc bfc" id="L336" title="All 2 branches covered.">      for (Map.Entry&lt;String, String&gt; t : tags.entrySet()) {</span>
<span class="fc" id="L337">        entries.addTag(new TagList(t.getKey(), t.getValue()));</span>
<span class="fc" id="L338">      }</span>
<span class="fc" id="L339">      head = createFromSortedTags(entries.sortedTags());</span>
<span class="fc" id="L340">    } else {</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">      for (Map.Entry&lt;String, String&gt; t : tags.entrySet()) {</span>
<span class="fc" id="L342">        head = new TagList(t.getKey(), t.getValue(), head);</span>
<span class="fc" id="L343">      }</span>
    }

<span class="fc" id="L346">    return head;</span>
  }

  /**
   * Create a tag list from a sorted list with no duplicates. The TagList is created with the
   * entries in the reverse order of the entries in the provided argument.
   *
   * @param sortedTags
   *     The sorted collection of tags to use to create the list
   * @return
   *     The newly constructed tag list or {@code EMPTY} if the iterable contains no entries
   */
  private static TagList createFromSortedTags(Iterable&lt;Tag&gt; sortedTags) {
<span class="fc" id="L359">    TagList head = EMPTY;</span>

<span class="fc bfc" id="L361" title="All 2 branches covered.">    for (Tag t : sortedTags) {</span>
<span class="fc" id="L362">      head = new TagList(t.key(), t.value(), head);</span>
<span class="fc" id="L363">    }</span>
<span class="fc" id="L364">    return head;</span>
  }

  /** Empty tag list. */
<span class="fc" id="L368">  static final TagList EMPTY = null;</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>
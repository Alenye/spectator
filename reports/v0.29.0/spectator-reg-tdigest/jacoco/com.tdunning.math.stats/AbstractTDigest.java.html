<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractTDigest.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spectator-reg-tdigest</a> &gt; <a href="index.source.html" class="el_package">com.tdunning.math.stats</a> &gt; <span class="el_source">AbstractTDigest.java</span></div><h1>AbstractTDigest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.tdunning.math.stats;

import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;

<span class="pc bpc" id="L26" title="1 of 2 branches missed.">public abstract class AbstractTDigest extends TDigest {</span>
<span class="fc" id="L27">    protected Random gen = new Random();</span>
<span class="fc" id="L28">    protected boolean recordAllData = false;</span>

    /**
     * Same as {@link #weightedAverageSorted(double, int, double, int)} but flips
     * the order of the variables if &lt;code&gt;x2&lt;/code&gt; is greater than
     * &lt;code&gt;x1&lt;/code&gt;.
     */
    public static double weightedAverage(double x1, int w1, double x2, int w2) {
<span class="fc bfc" id="L36" title="All 2 branches covered.">        if (x1 &lt;= x2) {</span>
<span class="fc" id="L37">            return weightedAverageSorted(x1, w1, x2, w2);</span>
        } else {
<span class="fc" id="L39">            return weightedAverageSorted(x2, w2, x1, w1);</span>
        }
    }

    /**
     * Compute the weighted average between &lt;code&gt;x1&lt;/code&gt; with a weight of
     * &lt;code&gt;w1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; with a weight of &lt;code&gt;w2&lt;/code&gt;.
     * This expects &lt;code&gt;x1&lt;/code&gt; to be less than or equal to &lt;code&gt;x2&lt;/code&gt;
     * and is guaranteed to return a number between &lt;code&gt;x1&lt;/code&gt; and
     * &lt;code&gt;x2&lt;/code&gt;.
     */
    public static double weightedAverageSorted(double x1, int w1, double x2, int w2) {
<span class="pc bpc" id="L51" title="2 of 4 branches missed.">        assert x1 &lt;= x2;</span>
<span class="fc" id="L52">        final double x = (x1 * w1 + x2 * w2) / (w1 + w2);</span>
<span class="fc" id="L53">        return Math.max(x1, Math.min(x, x2));</span>
    }

    public static double interpolate(double x, double x0, double x1) {
<span class="nc" id="L57">        return (x - x0) / (x1 - x0);</span>
    }

    public static void encode(ByteBuffer buf, int n) {
<span class="nc" id="L61">        int k = 0;</span>
<span class="nc bnc" id="L62" title="All 4 branches missed.">        while (n &lt; 0 || n &gt; 0x7f) {</span>
<span class="nc" id="L63">            byte b = (byte) (0x80 | (0x7f &amp; n));</span>
<span class="nc" id="L64">            buf.put(b);</span>
<span class="nc" id="L65">            n = n &gt;&gt;&gt; 7;</span>
<span class="nc" id="L66">            k++;</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">            if (k &gt;= 6) {</span>
<span class="nc" id="L68">                throw new IllegalStateException(&quot;Size is implausibly large&quot;);</span>
            }
<span class="nc" id="L70">        }</span>
<span class="nc" id="L71">        buf.put((byte) n);</span>
<span class="nc" id="L72">    }</span>

    public static int decode(ByteBuffer buf) {
<span class="nc" id="L75">        int v = buf.get();</span>
<span class="nc" id="L76">        int z = 0x7f &amp; v;</span>
<span class="nc" id="L77">        int shift = 7;</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">        while ((v &amp; 0x80) != 0) {</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">            if (shift &gt; 28) {</span>
<span class="nc" id="L80">                throw new IllegalStateException(&quot;Shift too large in decode&quot;);</span>
            }
<span class="nc" id="L82">            v = buf.get();</span>
<span class="nc" id="L83">            z += (v &amp; 0x7f) &lt;&lt; shift;</span>
<span class="nc" id="L84">            shift += 7;</span>
        }
<span class="nc" id="L86">        return z;</span>
    }

    abstract void add(double x, int w, Centroid base);

    protected static TDigest merge(Iterable&lt;TDigest&gt; subData, Random gen, TDigest r) {
<span class="fc" id="L92">        List&lt;Centroid&gt; centroids = new ArrayList&lt;Centroid&gt;();</span>
<span class="fc" id="L93">        boolean recordAll = false;</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">        for (TDigest digest : subData) {</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">            for (Centroid centroid : digest.centroids()) {</span>
<span class="fc" id="L96">                centroids.add(centroid);</span>
<span class="fc" id="L97">            }</span>
<span class="fc" id="L98">            recordAll |= digest.isRecording();</span>
<span class="fc" id="L99">        }</span>
<span class="fc" id="L100">        Collections.shuffle(centroids, gen);</span>
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">        if (recordAll) {</span>
<span class="nc" id="L102">            r.recordAllData();</span>
        }

<span class="fc bfc" id="L105" title="All 2 branches covered.">        for (Centroid c : centroids) {</span>
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">            if (r.isRecording()) {</span>
                // TODO should do something better here.
            }
<span class="fc" id="L109">            ((AbstractTDigest) r).add(c.mean(), c.count(), c);</span>
<span class="fc" id="L110">        }</span>
<span class="fc" id="L111">        return r;</span>
    }

    static double quantile(double previousIndex, double index, double nextIndex, double previousMean, double nextMean) {
<span class="fc" id="L115">        final double delta = nextIndex - previousIndex;</span>
<span class="fc" id="L116">        final double previousWeight = (nextIndex - index) / delta;</span>
<span class="fc" id="L117">        final double nextWeight = (index - previousIndex) / delta;</span>
<span class="fc" id="L118">        return previousMean * previousWeight + nextMean * nextWeight;</span>
    }

    /**
     * Sets up so that all centroids will record all data assigned to them.  For testing only, really.
     */
    @Override
    public TDigest recordAllData() {
<span class="nc" id="L126">        recordAllData = true;</span>
<span class="nc" id="L127">        return this;</span>
    }

    @Override
    public boolean isRecording() {
<span class="fc" id="L132">        return recordAllData;</span>
    }

    /**
     * Adds a sample to a histogram.
     *
     * @param x The value to add.
     */
    @Override
    public void add(double x) {
<span class="fc" id="L142">        add(x, 1);</span>
<span class="fc" id="L143">    }</span>

    @Override
    public void add(TDigest other) {
<span class="nc" id="L147">        List&lt;Centroid&gt; tmp = new ArrayList&lt;Centroid&gt;();</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">        for (Centroid centroid : other.centroids()) {</span>
<span class="nc" id="L149">            tmp.add(centroid);</span>
<span class="nc" id="L150">        }</span>

<span class="nc" id="L152">        Collections.shuffle(tmp, gen);</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">        for (Centroid centroid : tmp) {</span>
<span class="nc" id="L154">            add(centroid.mean(), centroid.count(), centroid);</span>
<span class="nc" id="L155">        }</span>
<span class="nc" id="L156">    }</span>

    protected Centroid createCentroid(double mean, int id) {
<span class="nc" id="L159">        return new Centroid(mean, id, recordAllData);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>
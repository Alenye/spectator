<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ArrayDigest.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spectator-reg-tdigest</a> &gt; <a href="index.source.html" class="el_package">com.tdunning.math.stats</a> &gt; <span class="el_source">ArrayDigest.java</span></div><h1>ArrayDigest.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.tdunning.math.stats;

import java.nio.ByteBuffer;
import java.util.AbstractCollection;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;

/**
 * Array based implementation of a TDigest.
 * &lt;p/&gt;
 * This implementation is essentially a one-level b-tree in which nodes are collected into
 * pages typically with 32 values per page.  Commonly, an ArrayDigest contains 500-3000
 * centroids.  With 32 values per page, we have about 32 values per page and about 30 pages
 * which seems to give a nice balance for speed.  Sizes from 4 to 100 are plausible, however.
 */
<span class="nc bnc" id="L37" title="All 2 branches missed.">public class ArrayDigest extends AbstractTDigest {</span>
    private final int pageSize;

<span class="nc" id="L40">    private List&lt;Page&gt; data = new ArrayList&lt;Page&gt;();</span>
<span class="nc" id="L41">    private long totalWeight = 0;</span>
<span class="nc" id="L42">    private int centroidCount = 0;</span>
<span class="nc" id="L43">    private double compression = 100;</span>

<span class="nc" id="L45">    public ArrayDigest(int pageSize, double compression) {</span>
<span class="nc bnc" id="L46" title="All 2 branches missed.">        if (pageSize &gt; 3) {</span>
<span class="nc" id="L47">            this.pageSize = pageSize;</span>
<span class="nc" id="L48">            this.compression = compression;</span>
        } else {
<span class="nc" id="L50">            throw new IllegalArgumentException(&quot;Must have page size of 4 or more&quot;);</span>
        }
<span class="nc" id="L52">    }</span>

    @Override
    public void add(double x, int w) {
<span class="nc" id="L56">        checkValue(x);</span>
<span class="nc" id="L57">        Index start = floor(x);</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">        if (start == null) {</span>
<span class="nc" id="L59">            start = ceiling(x);</span>
        }

<span class="nc bnc" id="L62" title="All 2 branches missed.">        if (start == null) {</span>
<span class="nc" id="L63">            addRaw(x, w);</span>
        } else {
<span class="nc" id="L65">            Iterable&lt;Index&gt; neighbors = inclusiveTail(start);</span>
<span class="nc" id="L66">            double minDistance = Double.MAX_VALUE;</span>
<span class="nc" id="L67">            int lastNeighbor = 0;</span>
<span class="nc" id="L68">            int i = 0;</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">            for (Index neighbor : neighbors) {</span>
<span class="nc" id="L70">                double z = Math.abs(mean(neighbor) - x);</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">                if (z &lt;= minDistance) {</span>
<span class="nc" id="L72">                    minDistance = z;</span>
<span class="nc" id="L73">                    lastNeighbor = i;</span>
                } else {
                    // as soon as z exceeds the minimum, we have passed the nearest neighbor and can quit
                    break;
                }
<span class="nc" id="L78">                i++;</span>
<span class="nc" id="L79">            }</span>

<span class="nc" id="L81">            Index closest = null;</span>
<span class="nc" id="L82">            long sum = headSum(start);</span>
<span class="nc" id="L83">            i = 0;</span>
<span class="nc" id="L84">            double n = 0;</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">            for (Index neighbor : neighbors) {</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">                if (i &gt; lastNeighbor) {</span>
<span class="nc" id="L87">                    break;</span>
                }
<span class="nc" id="L89">                double z = Math.abs(mean(neighbor) - x);</span>
<span class="nc" id="L90">                double q = (sum + count(neighbor) / 2.0) / totalWeight;</span>
<span class="nc" id="L91">                double k = 4 * totalWeight * q * (1 - q) / compression;</span>

                // this slightly clever selection method improves accuracy with lots of repeated points
<span class="nc bnc" id="L94" title="All 4 branches missed.">                if (z == minDistance &amp;&amp; count(neighbor) + w &lt;= k) {</span>
<span class="nc" id="L95">                    n++;</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">                    if (gen.nextDouble() &lt; 1 / n) {</span>
<span class="nc" id="L97">                        closest = neighbor;</span>
                    }
                }
<span class="nc" id="L100">                sum += count(neighbor);</span>
<span class="nc" id="L101">                i++;</span>
<span class="nc" id="L102">            }</span>

<span class="nc bnc" id="L104" title="All 2 branches missed.">            if (closest == null) {</span>
<span class="nc" id="L105">                addRaw(x, w);</span>
            } else {
<span class="nc bnc" id="L107" title="All 2 branches missed.">                if (n == 1) {</span>
                    // if the nearest point was unique, centroid ordering cannot change
<span class="nc" id="L109">                    Page p = data.get(closest.page);</span>
<span class="nc" id="L110">                    p.centroids[closest.subPage] = weightedAverage(p.centroids[closest.subPage], p.counts[closest.subPage], x, w);</span>
<span class="nc" id="L111">                    p.counts[closest.subPage] += w;</span>
<span class="nc" id="L112">                    p.totalCount += w;</span>
<span class="nc bnc" id="L113" title="All 4 branches missed.">                    if (p.history != null &amp;&amp; p.history.get(closest.subPage) != null) {</span>
<span class="nc" id="L114">                        p.history.get(closest.subPage).add(x);</span>
                    }
<span class="nc" id="L116">                    totalWeight += w;</span>
<span class="nc bnc" id="L117" title="All 4 branches missed.">                    assert p.sorted();</span>
<span class="nc" id="L118">                } else {</span>
                    // if the nearest point was not unique, then we may not be modifying the first copy
                    // which means that ordering can change
<span class="nc" id="L121">                    int weight = count(closest) + w;</span>
<span class="nc" id="L122">                    double center = mean(closest);</span>
<span class="nc" id="L123">                    center = center + (x - center) / weight;</span>

<span class="nc bnc" id="L125" title="All 4 branches missed.">                    if (mean(increment(closest, -1)) &lt;= center &amp;&amp; mean(increment(closest, 1)) &gt;= center) {</span>
                        // if order doesn't change, we can short-cut the process
<span class="nc" id="L127">                        Page p = data.get(closest.page);</span>
<span class="nc" id="L128">                        p.counts[closest.subPage] = weight;</span>
<span class="nc" id="L129">                        p.centroids[closest.subPage] = center;</span>

<span class="nc" id="L131">                        p.totalCount += w;</span>
<span class="nc" id="L132">                        totalWeight += w;</span>
<span class="nc bnc" id="L133" title="All 4 branches missed.">                        if (p.history != null &amp;&amp; p.history.get(closest.subPage) != null) {</span>
<span class="nc" id="L134">                            p.history.get(closest.subPage).add(x);</span>
                        }
<span class="nc" id="L136">                    } else {</span>
<span class="nc" id="L137">                        delete(closest);</span>

<span class="nc" id="L139">                        List&lt;Double&gt; history = history(closest);</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">                        if (history != null) {</span>
<span class="nc" id="L141">                            history.add(x);</span>
                        }

<span class="nc" id="L144">                        addRaw(center, weight, history);</span>
                    }

                }
            }

<span class="nc bnc" id="L150" title="All 2 branches missed.">            if (centroidCount &gt; 20 * compression) {</span>
                // something such as sequential ordering of data points
                // has caused a pathological expansion of our summary.
                // To fight this, we simply replay the current centroids
                // in random order.

                // this causes us to forget the diagnostic recording of data points
<span class="nc" id="L157">                compress();</span>
            }
        }
<span class="nc" id="L160">    }</span>

    public long headSum(Index limit) {
<span class="nc" id="L163">        long r = 0;</span>

<span class="nc bnc" id="L165" title="All 4 branches missed.">        for (int i = 0; limit != null &amp;&amp; i &lt; limit.page; i++) {</span>
<span class="nc" id="L166">            r += data.get(i).totalCount;</span>
        }

<span class="nc bnc" id="L169" title="All 4 branches missed.">        if (limit != null &amp;&amp; limit.page &lt; data.size()) {</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">            for (int j = 0; j &lt; limit.subPage; j++) {</span>
<span class="nc" id="L171">                r += data.get(limit.page).counts[j];</span>
            }
        }

<span class="nc" id="L175">        return r;</span>
    }

    public double mean(Index index) {
<span class="nc" id="L179">        return data.get(index.page).centroids[index.subPage];</span>
    }

    public int count(Index index) {
<span class="nc" id="L183">        return data.get(index.page).counts[index.subPage];</span>
    }

    @Override
    public void compress() {
<span class="nc" id="L188">        ArrayDigest reduced = new ArrayDigest(pageSize, compression);</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">        if (recordAllData) {</span>
<span class="nc" id="L190">            reduced.recordAllData();</span>
        }
<span class="nc" id="L192">        List&lt;Index&gt; tmp = new ArrayList&lt;Index&gt;();</span>
<span class="nc" id="L193">        Iterator&lt;Index&gt; ix = this.iterator(0, 0);</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">        while (ix.hasNext()) {</span>
<span class="nc" id="L195">            tmp.add(ix.next());</span>
        }

<span class="nc" id="L198">        Collections.shuffle(tmp, gen);</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">        for (Index index : tmp) {</span>
<span class="nc" id="L200">            reduced.add(mean(index), count(index));</span>
<span class="nc" id="L201">        }</span>

<span class="nc" id="L203">        data = reduced.data;</span>
<span class="nc" id="L204">        centroidCount = reduced.centroidCount;</span>
<span class="nc" id="L205">    }</span>

    @Override
    public long size() {
<span class="nc" id="L209">        return totalWeight;</span>
    }

    @Override
    public double cdf(double x) {
<span class="nc bnc" id="L214" title="All 2 branches missed.">        if (size() == 0) {</span>
<span class="nc" id="L215">            return Double.NaN;</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">        } else if (size() == 1) {</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">            return x &lt; data.get(0).centroids[0] ? 0 : 1;</span>
        } else {
<span class="nc" id="L219">            double r = 0;</span>

            // we scan a across the centroids
<span class="nc" id="L222">            Iterator&lt;Index&gt; it = iterator(0, 0);</span>
<span class="nc" id="L223">            Index a = it.next();</span>

            // b is the look-ahead to the next centroid
<span class="nc" id="L226">            Index b = it.next();</span>

            // initially, we set left width equal to right width
<span class="nc" id="L229">            double left = (b.mean() - a.mean()) / 2;</span>
<span class="nc" id="L230">            double right = left;</span>

            // scan to next to last element
<span class="nc bnc" id="L233" title="All 2 branches missed.">            while (it.hasNext()) {</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">                if (x &lt; a.mean() + right) {</span>
<span class="nc" id="L235">                    return (r + a.count() * AbstractTDigest.interpolate(x, a.mean() - left, a.mean() + right)) / totalWeight;</span>
                }
<span class="nc" id="L237">                r += a.count();</span>

<span class="nc" id="L239">                a = b;</span>
<span class="nc" id="L240">                b = it.next();</span>

<span class="nc" id="L242">                left = right;</span>
<span class="nc" id="L243">                right = (b.mean() - a.mean()) / 2;</span>
            }

            // for the last element, assume right width is same as left
<span class="nc" id="L247">            left = right;</span>
<span class="nc" id="L248">            a = b;</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">            if (x &lt; a.mean() + right) {</span>
<span class="nc" id="L250">                return (r + a.count() * AbstractTDigest.interpolate(x, a.mean() - left, a.mean() + right)) / totalWeight;</span>
            } else {
<span class="nc" id="L252">                return 1;</span>
            }
        }
    }

    @Override
    public double quantile(double q) {
<span class="nc bnc" id="L259" title="All 4 branches missed.">        if (q &lt; 0 || q &gt; 1) {</span>
<span class="nc" id="L260">            throw new IllegalArgumentException(&quot;q should be in [0,1], got &quot; + q);</span>
        }

<span class="nc bnc" id="L263" title="All 2 branches missed.">        if (centroidCount == 0) {</span>
<span class="nc" id="L264">            return Double.NaN;</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">        } else if (centroidCount == 1) {</span>
<span class="nc" id="L266">            return data.get(0).centroids[0];</span>
        }

        // if values were stored in a sorted array, index would be the offset we are interested in
<span class="nc" id="L270">        final double index = q * (size() - 1);</span>

<span class="nc" id="L272">        double previousMean = Double.NaN, previousIndex = 0;</span>
<span class="nc" id="L273">        long total = 0;</span>
        // Jump over pages until we reach the page containing the quantile we are interested in
<span class="nc" id="L275">        int firstPage = 0;</span>
<span class="nc bnc" id="L276" title="All 4 branches missed.">        while (firstPage &lt; data.size() &amp;&amp; total + data.get(firstPage).totalCount &lt; index) {</span>
<span class="nc" id="L277">            total += data.get(firstPage++).totalCount;</span>
        }
        Iterator&lt;Index&gt; it;
<span class="nc bnc" id="L280" title="All 2 branches missed.">        if (firstPage == 0) {</span>
            // start from the beginning
<span class="nc" id="L282">            it = iterator(0, 0);</span>
        } else {
<span class="nc" id="L284">            final int previousPageIndex = firstPage - 1;</span>
<span class="nc" id="L285">            final Page previousPage = data.get(previousPageIndex);</span>
<span class="nc bnc" id="L286" title="All 4 branches missed.">            assert previousPage.active &gt; 0;</span>
<span class="nc" id="L287">            final int lastSubPage = previousPage.active - 1;</span>
<span class="nc" id="L288">            previousMean = previousPage.centroids[lastSubPage];</span>
<span class="nc" id="L289">            previousIndex = total - (previousPage.counts[lastSubPage] + 1.0) / 2;</span>
<span class="nc" id="L290">            it = iterator(firstPage, 0);</span>
        }
        Index next;
        while (true) {
<span class="nc" id="L294">            next = it.next();</span>
<span class="nc" id="L295">            final double nextIndex = total + (next.count() - 1.0) / 2;</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">            if (nextIndex &gt;= index) {</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">                if (Double.isNaN(previousMean)) {</span>
<span class="nc bnc" id="L298" title="All 4 branches missed.">                    assert total == 0;</span>
                    // special case 1: the index we are interested in is before the 1st centroid
<span class="nc bnc" id="L300" title="All 2 branches missed.">                    if (nextIndex == previousIndex) {</span>
<span class="nc" id="L301">                        return next.mean();</span>
                    }
                    // assume values grow linearly between index previousIndex=0 and nextIndex2
<span class="nc" id="L304">                    Index next2 = it.next();</span>
<span class="nc" id="L305">                    final double nextIndex2 = total + next.count() + (next2.count() - 1.0) / 2;</span>
<span class="nc" id="L306">                    previousMean = (nextIndex2 * next.mean() - nextIndex * next2.mean()) / (nextIndex2 - nextIndex);</span>
                }
                // common case: we found two centroids previous and next so that the desired quantile is
                // after 'previous' but before 'next'
<span class="nc" id="L310">                return quantile(previousIndex, index, nextIndex, previousMean, next.mean());</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">            } else if (!it.hasNext()) {</span>
                // special case 2: the index we are interested in is beyond the last centroid
                // again, assume values grow linearly between index previousIndex and (count - 1)
                // which is the highest possible index
<span class="nc" id="L315">                final double nextIndex2 = size() - 1;</span>
<span class="nc" id="L316">                final double nextMean2 = (next.mean() * (nextIndex2 - previousIndex) - previousMean * (nextIndex2 - nextIndex)) / (nextIndex - previousIndex);</span>
<span class="nc" id="L317">                return quantile(nextIndex, index, nextIndex2, next.mean(), nextMean2);</span>
            }
<span class="nc" id="L319">            total += next.count();</span>
<span class="nc" id="L320">            previousMean = next.mean();</span>
<span class="nc" id="L321">            previousIndex = nextIndex;</span>
<span class="nc" id="L322">        }</span>
    }

    @Override
    public Collection&lt;Centroid&gt; centroids() {
<span class="nc" id="L327">        return new AbstractCollection&lt;Centroid&gt;() {</span>

            @Override
            public Iterator&lt;Centroid&gt; iterator() {
<span class="nc" id="L331">                final Iterator&lt;Index&gt; ix = ArrayDigest.this.iterator(0, 0);</span>
<span class="nc" id="L332">                return new Iterator&lt;Centroid&gt;() {</span>

                    @Override
                    public boolean hasNext() {
<span class="nc" id="L336">                        return ix.hasNext();</span>
                    }

                    @Override
                    public Centroid next() {
<span class="nc" id="L341">                        final Index index = ix.next();</span>
<span class="nc" id="L342">                        final Page current = data.get(index.page);</span>
<span class="nc" id="L343">                        Centroid centroid = new Centroid(current.centroids[index.subPage], current.counts[index.subPage]);</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">                        if (current.history != null) {</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">                            for (double x : current.history.get(index.subPage)) {</span>
<span class="nc" id="L346">                                centroid.insertData(x);</span>
<span class="nc" id="L347">                            }</span>
                        }
<span class="nc" id="L349">                        return centroid;</span>
                    }

                    @Override
                    public void remove() {
<span class="nc" id="L354">                        throw new UnsupportedOperationException();</span>
                    }
                };
            }

            @Override
            public int size() {
<span class="nc" id="L361">                return centroidCount;</span>
            }
        };
    }

    public Iterator&lt;Index&gt; allAfter(double x) {
<span class="nc bnc" id="L367" title="All 2 branches missed.">        if (data.size() == 0) {</span>
<span class="nc" id="L368">            return iterator(0, 0);</span>
        } else {

<span class="nc bnc" id="L371" title="All 2 branches missed.">            for (int i = 1; i &lt; data.size(); i++) {</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">                if (data.get(i).centroids[0] &gt;= x) {</span>
<span class="nc" id="L373">                    Page previous = data.get(i - 1);</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">                    for (int j = 0; j &lt; previous.active; j++) {</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">                        if (previous.centroids[j] &gt; x) {</span>
<span class="nc" id="L376">                            return iterator(i - 1, j);</span>
                        }
                    }
<span class="nc" id="L379">                    return iterator(i, 0);</span>
                }
            }

<span class="nc" id="L383">            Page last = data.get(data.size() - 1);</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">            for (int j = 0; j &lt; last.active; j++) {</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">                if (last.centroids[j] &gt; x) {</span>
<span class="nc" id="L386">                    return iterator(data.size() - 1, j);</span>
                }
            }
<span class="nc" id="L389">            return iterator(data.size(), 0);</span>
        }
    }

    /**
     * Returns a cursor pointing to the first element &lt;= x.  Exposed only for testing.
     * @param x The value used to find the cursor.
     * @return The cursor.
     */
    public Index floor(double x) {
<span class="nc" id="L399">        Iterator&lt;Index&gt; rx = allBefore(x);</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">        if (!rx.hasNext()) {</span>
<span class="nc" id="L401">            return null;</span>
        }
<span class="nc" id="L403">        Index r = rx.next();</span>
<span class="nc" id="L404">        Index z = r;</span>
<span class="nc bnc" id="L405" title="All 4 branches missed.">        while (rx.hasNext() &amp;&amp; mean(z) == x) {</span>
<span class="nc" id="L406">            r = z;</span>
<span class="nc" id="L407">            z = rx.next();</span>
        }
<span class="nc" id="L409">        return r;</span>
    }

    public Index ceiling(double x) {
<span class="nc" id="L413">        Iterator&lt;Index&gt; r = allAfter(x);</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">        return r.hasNext() ? r.next() : null;</span>
    }

    /**
     * Returns an iterator which will give each element &lt;= to x in non-increasing order.
     *
     * @param x The upper bound of all returned elements
     * @return An iterator that returns elements in non-increasing order.
     */
    public Iterator&lt;Index&gt; allBefore(double x) {
<span class="nc bnc" id="L424" title="All 2 branches missed.">        if (data.size() == 0) {</span>
<span class="nc" id="L425">            return iterator(0, 0);</span>
        } else {
<span class="nc bnc" id="L427" title="All 2 branches missed.">            for (int i = 1; i &lt; data.size(); i++) {</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">                if (data.get(i).centroids[0] &gt; x) {</span>
<span class="nc" id="L429">                    Page previous = data.get(i - 1);</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">                    for (int j = 0; j &lt; previous.active; j++) {</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">                        if (previous.centroids[j] &gt; x) {</span>
<span class="nc" id="L432">                            return reverse(i - 1, j - 1);</span>
                        }
                    }
<span class="nc" id="L435">                    return reverse(i, -1);</span>
                }
            }
<span class="nc" id="L438">            Page last = data.get(data.size() - 1);</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">            for (int j = 0; j &lt; last.active; j++) {</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">                if (last.centroids[j] &gt; x) {</span>
<span class="nc" id="L441">                    return reverse(data.size() - 1, j - 1);</span>
                }
            }
<span class="nc" id="L444">            return reverse(data.size(), -1);</span>
        }
    }

    public Index increment(Index x, int delta) {
<span class="nc" id="L449">        int i = x.page;</span>
<span class="nc" id="L450">        int j = x.subPage + delta;</span>

<span class="nc bnc" id="L452" title="All 4 branches missed.">        while (i &lt; data.size() &amp;&amp; j &gt;= data.get(i).active) {</span>
<span class="nc" id="L453">            j -= data.get(i).active;</span>
<span class="nc" id="L454">            i++;</span>
        }

<span class="nc bnc" id="L457" title="All 4 branches missed.">        while (i &gt; 0 &amp;&amp; j &lt; 0) {</span>
<span class="nc" id="L458">            i--;</span>
<span class="nc" id="L459">            j += data.get(i).active;</span>
        }
<span class="nc" id="L461">        return new Index(i, j);</span>
    }

    @Override
    public double compression() {
<span class="nc" id="L466">        return compression;</span>
    }

    /**
     * Returns an upper bound on the number bytes that will be required to represent this histogram.
     */
    @Override
    public int byteSize() {
<span class="nc" id="L474">        return 4 + 8 + 8 + centroidCount * 12;</span>
    }

    /**
     * Returns an upper bound on the number of bytes that will be required to represent this histogram in
     * the tighter representation.
     */
    @Override
    public int smallByteSize() {
<span class="nc" id="L483">        int bound = byteSize();</span>
<span class="nc" id="L484">        ByteBuffer buf = ByteBuffer.allocate(bound);</span>
<span class="nc" id="L485">        asSmallBytes(buf);</span>
<span class="nc" id="L486">        return buf.position();</span>
    }

    /**
     * Outputs a histogram as bytes using a particularly cheesy encoding.
     */
    @Override
    public void asBytes(ByteBuffer buf) {
<span class="nc" id="L494">        buf.putInt(VERBOSE_ARRAY_DIGEST);</span>
<span class="nc" id="L495">        buf.putDouble(compression());</span>
<span class="nc" id="L496">        buf.putInt(pageSize);</span>
<span class="nc" id="L497">        buf.putInt(centroidCount);</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">        for (Page page : data) {</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">            for (int i = 0; i &lt; page.active; i++) {</span>
<span class="nc" id="L500">                buf.putDouble(page.centroids[i]);</span>
            }
<span class="nc" id="L502">        }</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">        for (Page page : data) {</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">            for (int i = 0; i &lt; page.active; i++) {</span>
<span class="nc" id="L505">                buf.putInt(page.counts[i]);</span>
            }
<span class="nc" id="L507">        }</span>
<span class="nc" id="L508">    }</span>

    @Override
    public void asSmallBytes(ByteBuffer buf) {
<span class="nc" id="L512">        buf.putInt(SMALL_ARRAY_DIGEST);</span>
<span class="nc" id="L513">        buf.putDouble(compression());</span>
<span class="nc" id="L514">        buf.putInt(pageSize);</span>
<span class="nc" id="L515">        buf.putInt(centroidCount);</span>

<span class="nc" id="L517">        double x = 0;</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">        for (Page page : data) {</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">            for (int i = 0; i &lt; page.active; i++) {</span>
<span class="nc" id="L520">                double mean = page.centroids[i];</span>
<span class="nc" id="L521">                double delta = mean - x;</span>
<span class="nc" id="L522">                x = mean;</span>
<span class="nc" id="L523">                buf.putFloat((float) delta);</span>
            }
<span class="nc" id="L525">        }</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">        for (Page page : data) {</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">            for (int i = 0; i &lt; page.active; i++) {</span>
<span class="nc" id="L528">                int n = page.counts[i];</span>
<span class="nc" id="L529">                encode(buf, n);</span>
            }
<span class="nc" id="L531">        }</span>
<span class="nc" id="L532">    }</span>

    /**
     * Reads a histogram from a byte buffer
     *
     * @return The new histogram structure
     */
    public static ArrayDigest fromBytes(ByteBuffer buf) {
<span class="nc" id="L540">        int encoding = buf.getInt();</span>
<span class="nc bnc" id="L541" title="All 4 branches missed.">        if (encoding == VERBOSE_ENCODING || encoding == VERBOSE_ARRAY_DIGEST) {</span>
<span class="nc" id="L542">            double compression = buf.getDouble();</span>
<span class="nc" id="L543">            int pageSize = 32;</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">            if (encoding == VERBOSE_ARRAY_DIGEST) {</span>
<span class="nc" id="L545">                pageSize = buf.getInt();</span>
            }
<span class="nc" id="L547">            ArrayDigest r = new ArrayDigest(pageSize, compression);</span>
<span class="nc" id="L548">            int n = buf.getInt();</span>
<span class="nc" id="L549">            double[] means = new double[n];</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L551">                means[i] = buf.getDouble();</span>
            }
<span class="nc bnc" id="L553" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L554">                r.add(means[i], buf.getInt());</span>
            }
<span class="nc" id="L556">            return r;</span>
<span class="nc bnc" id="L557" title="All 4 branches missed.">        } else if (encoding == SMALL_ENCODING || encoding == SMALL_ARRAY_DIGEST) {</span>
<span class="nc" id="L558">            double compression = buf.getDouble();</span>
<span class="nc" id="L559">            int pageSize = 32;</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">            if (encoding == SMALL_ARRAY_DIGEST) {</span>
<span class="nc" id="L561">                pageSize = buf.getInt();</span>
            }
<span class="nc" id="L563">            ArrayDigest r = new ArrayDigest(pageSize, compression);</span>
<span class="nc" id="L564">            int n = buf.getInt();</span>
<span class="nc" id="L565">            double[] means = new double[n];</span>
<span class="nc" id="L566">            double x = 0;</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L568">                double delta = buf.getFloat();</span>
<span class="nc" id="L569">                x += delta;</span>
<span class="nc" id="L570">                means[i] = x;</span>
            }

<span class="nc bnc" id="L573" title="All 2 branches missed.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L574">                int z = decode(buf);</span>
<span class="nc" id="L575">                r.add(means[i], z);</span>
            }
<span class="nc" id="L577">            return r;</span>
        } else {
<span class="nc" id="L579">            throw new IllegalStateException(&quot;Invalid format for serialized histogram&quot;);</span>
        }
    }

    private List&lt;Double&gt; history(Index index) {
<span class="nc" id="L584">        List&lt;List&lt;Double&gt;&gt; h = data.get(index.page).history;</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">        return h == null ? null : h.get(index.subPage);</span>
    }

    private void delete(Index index) {
        // don't want to delete empty pages here because other indexes would be screwed up.
        // this should almost never happen anyway since deletes only cause small ordering
        // changes
<span class="nc" id="L592">        totalWeight -= count(index);</span>
<span class="nc" id="L593">        centroidCount--;</span>
<span class="nc" id="L594">        data.get(index.page).delete(index.subPage);</span>
<span class="nc" id="L595">    }</span>

    private Iterable&lt;Index&gt; inclusiveTail(final Index start) {
<span class="nc" id="L598">        return new Iterable&lt;Index&gt;() {</span>
            @Override
            public Iterator&lt;Index&gt; iterator() {
<span class="nc" id="L601">                return ArrayDigest.this.iterator(start.page, start.subPage);</span>
            }
        };
    }

    void addRaw(double x, int w) {
<span class="nc" id="L607">        List&lt;Double&gt; tmp = new ArrayList&lt;Double&gt;();</span>
<span class="nc" id="L608">        tmp.add(x);</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">        addRaw(x, w, recordAllData ? tmp : null);</span>
<span class="nc" id="L610">    }</span>

    void addRaw(double x, int w, List&lt;Double&gt; history) {
<span class="nc bnc" id="L613" title="All 2 branches missed.">        if (centroidCount == 0) {</span>
<span class="nc" id="L614">            Page page = new Page(pageSize, recordAllData);</span>
<span class="nc" id="L615">            page.add(x, w, history);</span>
<span class="nc" id="L616">            totalWeight += w;</span>
<span class="nc" id="L617">            centroidCount++;</span>
<span class="nc" id="L618">            data.add(page);</span>
<span class="nc" id="L619">        } else {</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">            for (int i = 1; i &lt; data.size(); i++) {</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">                if (data.get(i).centroids[0] &gt; x) {</span>
<span class="nc" id="L622">                    Page newPage = data.get(i - 1).add(x, w, history);</span>
<span class="nc" id="L623">                    totalWeight += w;</span>
<span class="nc" id="L624">                    centroidCount++;</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">                    if (newPage != null) {</span>
<span class="nc" id="L626">                        data.add(i, newPage);</span>
                    }
<span class="nc" id="L628">                    return;</span>
                }
            }
<span class="nc" id="L631">            Page newPage = data.get(data.size() - 1).add(x, w, history);</span>
<span class="nc" id="L632">            totalWeight += w;</span>
<span class="nc" id="L633">            centroidCount++;</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">            if (newPage != null) {</span>
<span class="nc" id="L635">                data.add(data.size(), newPage);</span>
            }
        }
<span class="nc" id="L638">    }</span>

    @Override
    void add(double x, int w, Centroid base) {
<span class="nc" id="L642">        addRaw(x, w, base.data());</span>
<span class="nc" id="L643">    }</span>

    private Iterator&lt;Index&gt; iterator(final int startPage, final int startSubPage) {
<span class="nc" id="L646">        return new Iterator&lt;Index&gt;() {</span>
<span class="nc" id="L647">            int page = startPage;</span>
<span class="nc" id="L648">            int subPage = startSubPage;</span>
<span class="nc" id="L649">            Index end = new Index(-1, -1);</span>
<span class="nc" id="L650">            Index next = null;</span>

            @Override
            public boolean hasNext() {
<span class="nc bnc" id="L654" title="All 2 branches missed.">                if (next == null) {</span>
<span class="nc" id="L655">                    next = computeNext();</span>
                }
<span class="nc bnc" id="L657" title="All 2 branches missed.">                return next != end;</span>
            }

            @Override
            public Index next() {
<span class="nc bnc" id="L662" title="All 2 branches missed.">                if (hasNext()) {</span>
<span class="nc" id="L663">                    Index r = next;</span>
<span class="nc" id="L664">                    next = null;</span>
<span class="nc" id="L665">                    return r;</span>
                } else {
<span class="nc" id="L667">                    throw new NoSuchElementException(&quot;Can't iterate past end of data&quot;);</span>
                }
            }

            @Override
            public void remove() {
<span class="nc" id="L673">                throw new UnsupportedOperationException(&quot;Default operation&quot;);</span>
            }

            protected Index computeNext() {
<span class="nc bnc" id="L677" title="All 2 branches missed.">                if (page &gt;= data.size()) {</span>
<span class="nc" id="L678">                    return end;</span>
                } else {
<span class="nc" id="L680">                    Page current = data.get(page);</span>
<span class="nc bnc" id="L681" title="All 2 branches missed.">                    if (subPage &gt;= current.active) {</span>
<span class="nc" id="L682">                        subPage = 0;</span>
<span class="nc" id="L683">                        page++;</span>
<span class="nc" id="L684">                        return computeNext();</span>
                    } else {
<span class="nc" id="L686">                        Index r = new Index(page, subPage);</span>
<span class="nc" id="L687">                        subPage++;</span>
<span class="nc" id="L688">                        return r;</span>
                    }
                }
            }
        };
    }

    private Iterator&lt;Index&gt; reverse(final int startPage, final int startSubPage) {
<span class="nc" id="L696">        return new Iterator&lt;Index&gt;() {</span>
<span class="nc" id="L697">            int page = startPage;</span>
<span class="nc" id="L698">            int subPage = startSubPage;</span>

<span class="nc" id="L700">            Index end = new Index(-1, -1);</span>
<span class="nc" id="L701">            Index next = null;</span>

            @Override
            public boolean hasNext() {
<span class="nc bnc" id="L705" title="All 2 branches missed.">                if (next == null) {</span>
<span class="nc" id="L706">                    next = computeNext();</span>
                }
<span class="nc bnc" id="L708" title="All 2 branches missed.">                return next != end;</span>
            }

            @Override
            public Index next() {
<span class="nc bnc" id="L713" title="All 2 branches missed.">                if (hasNext()) {</span>
<span class="nc" id="L714">                    Index r = next;</span>
<span class="nc" id="L715">                    next = null;</span>
<span class="nc" id="L716">                    return r;</span>
                } else {
<span class="nc" id="L718">                    throw new NoSuchElementException(&quot;Can't reverse iterate before beginning of data&quot;);</span>
                }
            }

            @Override
            public void remove() {
<span class="nc" id="L724">                throw new UnsupportedOperationException(&quot;Default operation&quot;);</span>
            }

            protected Index computeNext() {
<span class="nc bnc" id="L728" title="All 2 branches missed.">                if (page &lt; 0) {</span>
<span class="nc" id="L729">                    return end;</span>
                } else {
<span class="nc bnc" id="L731" title="All 2 branches missed.">                    if (subPage &lt; 0) {</span>
<span class="nc" id="L732">                        page--;</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">                        if (page &gt;= 0) {</span>
<span class="nc" id="L734">                            subPage = data.get(page).active - 1;</span>
                        }
<span class="nc" id="L736">                        return computeNext();</span>
                    } else {
<span class="nc" id="L738">                        Index r = new Index(page, subPage);</span>
<span class="nc" id="L739">                        subPage--;</span>
<span class="nc" id="L740">                        return r;</span>
                    }
                }
            }
        };
    }

    public final static int VERBOSE_ENCODING = 1;
    public final static int SMALL_ENCODING = 2;
    public final static int VERBOSE_ARRAY_DIGEST = 3;
    public final static int SMALL_ARRAY_DIGEST = 4;

    class Index {
        final int page, subPage;

<span class="nc" id="L755">        private Index(int page, int subPage) {</span>
<span class="nc" id="L756">            this.page = page;</span>
<span class="nc" id="L757">            this.subPage = subPage;</span>
<span class="nc" id="L758">        }</span>

        double mean() {
<span class="nc" id="L761">            return data.get(page).centroids[subPage];</span>
        }

        int count() {
<span class="nc" id="L765">            return data.get(page).counts[subPage];</span>
        }
    }

<span class="nc bnc" id="L769" title="All 2 branches missed.">    private static class Page {</span>
        private final boolean recordAllData;
        private final int pageSize;

        long totalCount;
        int active;
        double[] centroids;
        int[] counts;
        List&lt;List&lt;Double&gt;&gt; history;

<span class="nc" id="L779">        private Page(int pageSize, boolean recordAllData) {</span>
<span class="nc" id="L780">            this.pageSize = pageSize;</span>
<span class="nc" id="L781">            this.recordAllData = recordAllData;</span>
<span class="nc" id="L782">            centroids = new double[this.pageSize];</span>
<span class="nc" id="L783">            counts = new int[this.pageSize];</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">            history = this.recordAllData ? new ArrayList&lt;List&lt;Double&gt;&gt;() : null;</span>
<span class="nc" id="L785">        }</span>

        boolean sorted() {
<span class="nc bnc" id="L788" title="All 2 branches missed.">            for (int i = 1; i &lt; active; ++i) {</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">                if (centroids[i] &lt; centroids[i - 1]) {</span>
<span class="nc" id="L790">                    return false;</span>
                }
            }
<span class="nc" id="L793">            return true;</span>
        }

        public Page add(double x, int w, List&lt;Double&gt; history) {
<span class="nc bnc" id="L797" title="All 2 branches missed.">            for (int i = 0; i &lt; active; i++) {</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">                if (centroids[i] &gt;= x) {</span>
                    // insert at i
<span class="nc bnc" id="L800" title="All 2 branches missed.">                    if (active &gt;= pageSize) {</span>
                        // split page
<span class="nc" id="L802">                        Page newPage = split();</span>
<span class="nc bnc" id="L803" title="All 2 branches missed.">                        if (i &lt; pageSize / 2) {</span>
<span class="nc" id="L804">                            addAt(i, x, w, history);</span>
                        } else {
<span class="nc" id="L806">                            newPage.addAt(i - pageSize / 2, x, w, history);</span>
                        }
<span class="nc bnc" id="L808" title="All 4 branches missed.">                        assert sorted();</span>
<span class="nc bnc" id="L809" title="All 4 branches missed.">                        assert newPage.sorted();</span>
<span class="nc" id="L810">                        return newPage;</span>
                    } else {
<span class="nc" id="L812">                        addAt(i, x, w, history);</span>
<span class="nc bnc" id="L813" title="All 4 branches missed.">                        assert sorted();</span>
<span class="nc" id="L814">                        return null;</span>
                    }
                }
            }

            // insert at end
<span class="nc bnc" id="L820" title="All 2 branches missed.">            if (active &gt;= pageSize) {</span>
                // split page
<span class="nc" id="L822">                Page newPage = split();</span>
<span class="nc" id="L823">                newPage.addAt(newPage.active, x, w, history);</span>
<span class="nc bnc" id="L824" title="All 4 branches missed.">                assert sorted();</span>
<span class="nc bnc" id="L825" title="All 4 branches missed.">                assert newPage.sorted();</span>
<span class="nc" id="L826">                return newPage;</span>
            } else {
<span class="nc" id="L828">                addAt(active, x, w, history);</span>
<span class="nc bnc" id="L829" title="All 4 branches missed.">                assert sorted();</span>
<span class="nc" id="L830">                return null;</span>
            }
        }

        private void addAt(int i, double x, int w, List&lt;Double&gt; history) {
<span class="nc bnc" id="L835" title="All 2 branches missed.">            if (i &lt; active) {</span>
                // shift data to make room
<span class="nc" id="L837">                System.arraycopy(centroids, i, centroids, i + 1, active - i);</span>
<span class="nc" id="L838">                System.arraycopy(counts, i, counts, i + 1, active - i);</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">                if (this.history != null) {</span>
<span class="nc" id="L840">                    this.history.add(i, history);</span>
                }
<span class="nc" id="L842">                centroids[i] = x;</span>
<span class="nc" id="L843">                counts[i] = w;</span>
            } else {
<span class="nc bnc" id="L845" title="All 4 branches missed.">                assert i == active;</span>
<span class="nc" id="L846">                centroids[active] = x;</span>
<span class="nc" id="L847">                counts[active] = w;</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">                if (this.history != null) {</span>
<span class="nc" id="L849">                    this.history.add(history);</span>
                }
            }
<span class="nc" id="L852">            active++;</span>
<span class="nc" id="L853">            totalCount += w;</span>
<span class="nc" id="L854">        }</span>

        private Page split() {
<span class="nc bnc" id="L857" title="All 4 branches missed.">            assert active == pageSize;</span>
<span class="nc" id="L858">            final int half = pageSize / 2;</span>
<span class="nc" id="L859">            Page newPage = new Page(pageSize, recordAllData);</span>
<span class="nc" id="L860">            System.arraycopy(centroids, half, newPage.centroids, 0, pageSize - half);</span>
<span class="nc" id="L861">            System.arraycopy(counts, half, newPage.counts, 0, pageSize - half);</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">            if (history != null) {</span>
<span class="nc" id="L863">                newPage.history = new ArrayList&lt;List&lt;Double&gt;&gt;();</span>
<span class="nc" id="L864">                newPage.history.addAll(history.subList(half, pageSize));</span>

<span class="nc" id="L866">                List&lt;List&lt;Double&gt;&gt; tmp = new ArrayList&lt;List&lt;Double&gt;&gt;();</span>
<span class="nc" id="L867">                tmp.addAll(history.subList(0, half));</span>
<span class="nc" id="L868">                history = tmp;</span>
            }
<span class="nc" id="L870">            active = half;</span>
<span class="nc" id="L871">            newPage.active = pageSize - half;</span>

<span class="nc" id="L873">            newPage.totalCount = totalCount;</span>
<span class="nc" id="L874">            totalCount = 0;</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">            for (int i = 0; i &lt; half; i++) {</span>
<span class="nc" id="L876">                totalCount += counts[i];</span>
<span class="nc" id="L877">                newPage.totalCount -= counts[i];</span>
            }

<span class="nc" id="L880">            return newPage;</span>
        }

        public void delete(int i) {
<span class="nc" id="L884">            int w = counts[i];</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">            if (i != active - 1) {</span>
<span class="nc" id="L886">                System.arraycopy(centroids, i + 1, centroids, i, active - i - 1);</span>
<span class="nc" id="L887">                System.arraycopy(counts, i + 1, counts, i, active - i - 1);</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">                if (history != null) {</span>
<span class="nc" id="L889">                    history.remove(i);</span>
                }
            }
<span class="nc" id="L892">            active--;</span>
<span class="nc" id="L893">            totalCount -= w;</span>
<span class="nc bnc" id="L894" title="All 4 branches missed.">            assert sorted();</span>
<span class="nc" id="L895">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>
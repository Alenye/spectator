<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>HttpLogEntry.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spectator-ext-sandbox</a> &gt; <a href="index.source.html" class="el_package">com.netflix.spectator.sandbox</a> &gt; <span class="el_source">HttpLogEntry.java</span></div><h1>HttpLogEntry.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.netflix.spectator.sandbox;

import com.netflix.spectator.api.Id;
import com.netflix.spectator.api.Registry;
import com.netflix.spectator.api.Spectator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.Marker;
import org.slf4j.MarkerFactory;

import java.net.URI;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

/**
 * Helper for logging http request related information.
 */
<span class="nc" id="L38">public class HttpLogEntry {</span>

<span class="nc" id="L40">  private static final Logger LOGGER = LoggerFactory.getLogger(HttpLogEntry.class);</span>

<span class="nc" id="L42">  private static final Marker CLIENT = MarkerFactory.getMarker(&quot;http-client&quot;);</span>
<span class="nc" id="L43">  private static final Marker SERVER = MarkerFactory.getMarker(&quot;http-server&quot;);</span>

<span class="nc" id="L45">  private static final Registry REGISTRY = Spectator.registry();</span>
<span class="nc" id="L46">  private static final Id COMPLETE = REGISTRY.createId(&quot;http.req.complete&quot;);</span>
<span class="nc" id="L47">  private static final Id ATTEMPT = REGISTRY.createId(&quot;http.req.attempt&quot;);</span>
<span class="nc" id="L48">  private static final Id REQ_HEADER_SIZE = REGISTRY.createId(&quot;http.req.headerSize&quot;);</span>
<span class="nc" id="L49">  private static final Id REQ_ENTITY_SIZE = REGISTRY.createId(&quot;http.req.entitySize&quot;);</span>
<span class="nc" id="L50">  private static final Id RES_HEADER_SIZE = REGISTRY.createId(&quot;http.res.headerSize&quot;);</span>
<span class="nc" id="L51">  private static final Id RES_ENTITY_SIZE = REGISTRY.createId(&quot;http.res.entitySize&quot;);</span>

<span class="nc" id="L53">  private static final BucketFunction BUCKETS = BucketFunctions.latency(</span>
<span class="nc" id="L54">      Spectator.config().getLong(&quot;spectator.http.maxLatency&quot;, 8000), TimeUnit.MILLISECONDS);</span>

  /**
   * Including the endpoint is useful, but we need to be careful about the number of
   * matches. A fixed prefix list is fairly easy to use and makes the number and set of matches
   * explicit.
   */
<span class="nc" id="L61">  private static final List&lt;String&gt; ENDPOINT_PREFIXES =</span>
<span class="nc" id="L62">      parseEndpoints(Spectator.config().get(&quot;spectator.http.endpointPrefixes&quot;, &quot;/healthcheck&quot;));</span>

  private static List&lt;String&gt; parseEndpoints(String s) {
<span class="nc bnc" id="L65" title="All 2 branches missed.">    String[] prefixes = (s == null) ? new String[] {} : s.split(&quot;[,\\s]+&quot;);</span>
<span class="nc" id="L66">    List&lt;String&gt; buf = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">    for (String prefix : prefixes) {</span>
<span class="nc" id="L68">      String tmp = prefix.trim();</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">      if (tmp.length() &gt; 0) {</span>
<span class="nc" id="L70">        buf.add(prefix);</span>
      }
    }
<span class="nc" id="L73">    Collections.sort(buf);</span>
<span class="nc" id="L74">    return buf;</span>
  }

  private static String longestPrefixMatch(String path, String dflt) {
<span class="nc bnc" id="L78" title="All 4 branches missed.">    if (path == null || path.length() == 0) {</span>
<span class="nc" id="L79">      return dflt;</span>
    }

<span class="nc" id="L82">    int length = 0;</span>
<span class="nc" id="L83">    String longest = null;</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">    for (String prefix : ENDPOINT_PREFIXES) {</span>
<span class="nc bnc" id="L85" title="All 4 branches missed.">      if (path.startsWith(prefix) &amp;&amp; prefix.length() &gt; length) {</span>
<span class="nc" id="L86">        longest = prefix;</span>
<span class="nc" id="L87">        length = prefix.length();</span>
      }
<span class="nc" id="L89">    }</span>

<span class="nc bnc" id="L91" title="All 2 branches missed.">    return (longest == null) ? dflt : longest;</span>
  }

  /** Log a client request. */
  public static void logClientRequest(HttpLogEntry entry) {
<span class="nc" id="L96">    log(LOGGER, CLIENT, entry);</span>
<span class="nc" id="L97">  }</span>

  /**
   * Log a client request.
   * @deprecated Use {@link #logClientRequest(HttpLogEntry)} instead.
   */
  @Deprecated
  public static void logClientRequest(Logger logger, HttpLogEntry entry) {
<span class="nc" id="L105">    log(logger, CLIENT, entry);</span>
<span class="nc" id="L106">  }</span>

  /** Log a request received by a server. */
  public static void logServerRequest(HttpLogEntry entry) {
<span class="nc" id="L110">    log(LOGGER, SERVER, entry);</span>
<span class="nc" id="L111">  }</span>

  /**
   * Log a request received by a server.
   * @deprecated Use {@link #logServerRequest(HttpLogEntry)} instead.
   */
  @Deprecated
  public static void logServerRequest(Logger logger, HttpLogEntry entry) {
<span class="nc" id="L119">    log(logger, SERVER, entry);</span>
<span class="nc" id="L120">  }</span>

  private static void log(Logger logger, Marker marker, HttpLogEntry entry) {
<span class="nc" id="L123">    Id dimensions = REGISTRY.createId(&quot;tags&quot;)</span>
<span class="nc" id="L124">        .withTag(&quot;mode&quot;, marker.getName())</span>
<span class="nc" id="L125">        .withTag(&quot;status&quot;, entry.getStatusTag())</span>
<span class="nc" id="L126">        .withTag(&quot;statusCode&quot;, entry.getStatusCodeTag())</span>
<span class="nc" id="L127">        .withTag(&quot;method&quot;, entry.method);</span>

<span class="nc bnc" id="L129" title="All 2 branches missed.">    if (entry.clientName != null) {</span>
<span class="nc" id="L130">      dimensions = dimensions.withTag(&quot;client&quot;, entry.clientName);</span>
    }

<span class="nc bnc" id="L133" title="All 4 branches missed.">    if (marker == SERVER &amp;&amp; entry.requestUri != null) {</span>
<span class="nc" id="L134">      String path = entry.requestUri.getPath();</span>
<span class="nc" id="L135">      dimensions = dimensions.withTag(&quot;endpoint&quot;, longestPrefixMatch(path, &quot;other&quot;));</span>
    }

    // Update stats for the final attempt after retries are exhausted
<span class="nc bnc" id="L139" title="All 4 branches missed.">    if (!entry.canRetry || entry.attempt &gt;= entry.maxAttempts) {</span>
<span class="nc" id="L140">      BucketTimer.get(REGISTRY, COMPLETE.withTags(dimensions.tags()), BUCKETS)</span>
<span class="nc" id="L141">          .record(entry.getOverallLatency(), TimeUnit.MILLISECONDS);</span>
    }

    // Update stats for every actual http request
<span class="nc" id="L145">    BucketTimer.get(REGISTRY, ATTEMPT.withTags(dimensions.tags()), BUCKETS)</span>
<span class="nc" id="L146">        .record(entry.getLatency(), TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L147">    REGISTRY.distributionSummary(REQ_HEADER_SIZE.withTags(dimensions.tags()))</span>
<span class="nc" id="L148">        .record(entry.getRequestHeadersLength());</span>
<span class="nc" id="L149">    REGISTRY.distributionSummary(REQ_ENTITY_SIZE.withTags(dimensions.tags()))</span>
<span class="nc" id="L150">        .record(entry.requestContentLength);</span>
<span class="nc" id="L151">    REGISTRY.distributionSummary(RES_HEADER_SIZE.withTags(dimensions.tags()))</span>
<span class="nc" id="L152">        .record(entry.getResponseHeadersLength());</span>
<span class="nc" id="L153">    REGISTRY.distributionSummary(RES_ENTITY_SIZE.withTags(dimensions.tags()))</span>
<span class="nc" id="L154">        .record(entry.responseContentLength);</span>

    // Write data out to logger if enabled. For many monitoring use-cases there tend to be
    // frequent requests that can be quite noisy so the log level is set to debug. This class is
    // mostly intended to generate something like an access log so it presumes users who want the
    // information will configure an appender based on the markers to send the data to a
    // dedicated file. Others shouldn't have to deal with the spam in the logs, so debug for the
    // level seems reasonable.
<span class="nc bnc" id="L162" title="All 2 branches missed.">    if (logger.isDebugEnabled(marker)) {</span>
<span class="nc" id="L163">      logger.debug(marker, entry.toString());</span>
    }
<span class="nc" id="L165">  }</span>

  /** Generate a new request id. */
  private static String newId() {
<span class="nc" id="L169">    return UUID.randomUUID().toString();</span>
  }

  // Cannot be static constant, date format is not thread-safe
<span class="nc" id="L173">  private final SimpleDateFormat isoDate = new SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss&quot;);</span>

<span class="nc" id="L175">  private String clientName = null;</span>

<span class="nc" id="L177">  private String requestId = newId();</span>

<span class="nc" id="L179">  private URI originalUri = null;</span>
<span class="nc" id="L180">  private URI requestUri = null;</span>
<span class="nc" id="L181">  private String method = null;</span>
<span class="nc" id="L182">  private List&lt;Header&gt; requestHeaders = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L183">  private long requestContentLength = -1;</span>

<span class="nc" id="L185">  private String remoteAddr = null;</span>
<span class="nc" id="L186">  private int remotePort = -1;</span>

<span class="nc" id="L188">  private String attemptId = requestId;</span>
<span class="nc" id="L189">  private int attempt = 1;</span>
<span class="nc" id="L190">  private int maxAttempts = -1;</span>
<span class="nc" id="L191">  private boolean canRetry = false;</span>

<span class="nc" id="L193">  private int redirect = 0;</span>

<span class="nc" id="L195">  private Throwable exception = null;</span>

<span class="nc" id="L197">  private int statusCode = -1;</span>
<span class="nc" id="L198">  private String statusReason = null;</span>
<span class="nc" id="L199">  private List&lt;Header&gt; responseHeaders = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L200">  private long responseContentLength = -1;</span>

<span class="nc" id="L202">  private List&lt;Event&gt; events = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L203">  private long latency = -1;</span>
<span class="nc" id="L204">  private long originalStart = -1;</span>

  private void reset(int redir) {
<span class="nc bnc" id="L207" title="All 4 branches missed.">    if (originalStart &lt; 0 &amp;&amp; !events.isEmpty()) {</span>
<span class="nc" id="L208">      originalStart = events.get(0).timestamp();</span>
    }
<span class="nc" id="L210">    requestHeaders.clear();</span>
<span class="nc" id="L211">    requestContentLength = -1;</span>
<span class="nc" id="L212">    remoteAddr = null;</span>
<span class="nc" id="L213">    remotePort = -1;</span>
<span class="nc" id="L214">    redirect = redir;</span>
<span class="nc" id="L215">    exception = null;</span>
<span class="nc" id="L216">    statusCode = -1;</span>
<span class="nc" id="L217">    responseHeaders.clear();</span>
<span class="nc" id="L218">    responseContentLength = -1;</span>
<span class="nc" id="L219">    events.clear();</span>
<span class="nc" id="L220">    latency = -1;</span>
<span class="nc" id="L221">  }</span>

  /** Set the name of the client, often used for clients to identify a particular config. */
  public HttpLogEntry withClientName(String name) {
<span class="nc" id="L225">    this.clientName = name;</span>
<span class="nc" id="L226">    return this;</span>
  }

  /**
   * Set the original uri. In the case of approaches with client-side load balancing this will
   * be some alias indicating the group of hosts. The request uri would indicate a specific host
   * used for an actual network request.
   */
  public HttpLogEntry withOriginalUri(URI uri) {
<span class="nc" id="L235">    this.originalUri = uri;</span>
<span class="nc" id="L236">    return this;</span>
  }

  /** Set the URI for the actual http request. */
  public HttpLogEntry withRequestUri(URI uri) {
<span class="nc" id="L241">    this.requestUri = uri;</span>
<span class="nc" id="L242">    return this;</span>
  }

  /** Set the method for the request. */
  public HttpLogEntry withMethod(String httpMethod) {
<span class="nc" id="L247">    this.method = httpMethod;</span>
<span class="nc" id="L248">    return this;</span>
  }

  /** Add a header that was on the request. */
  public HttpLogEntry withRequestHeader(String name, String value) {
<span class="nc" id="L253">    requestHeaders.add(new Header(name, value));</span>
<span class="nc" id="L254">    return this;</span>
  }

  /** Set the content-length for the request. */
  public HttpLogEntry withRequestContentLength(long size) {
<span class="nc" id="L259">    this.requestContentLength = size;</span>
<span class="nc" id="L260">    return this;</span>
  }

  /**
   * Set the remote address. For a client making a request this should be the server, for a
   * server receiving a request it should be the client.
   */
  public HttpLogEntry withRemoteAddr(String addr) {
<span class="nc" id="L268">    this.remoteAddr = addr;</span>
<span class="nc" id="L269">    return this;</span>
  }

  /**
   * Set the remote port. For a client making a request this should be the server, for a
   * server receiving a request it should be the client.
   */
  public HttpLogEntry withRemotePort(int port) {
<span class="nc" id="L277">    this.remotePort = port;</span>
<span class="nc" id="L278">    return this;</span>
  }

  /** Set the attempt if retries are used, should only be used after the initial request. */
  public HttpLogEntry withAttempt(int n) {
<span class="nc" id="L283">    this.attempt = n;</span>
<span class="nc" id="L284">    this.attemptId = newId();</span>
<span class="nc" id="L285">    reset(0);</span>
<span class="nc" id="L286">    return this;</span>
  }

  /** Set the attempt if redirect occurs, should only be used after the initial request. */
  public HttpLogEntry withRedirect(URI loc) {
<span class="nc" id="L291">    reset(redirect + 1);</span>
<span class="nc" id="L292">    return withRequestUri(loc);</span>
  }

  /** Set the max number of attempts that will be tried. */
  public HttpLogEntry withMaxAttempts(int attempts) {
<span class="nc" id="L297">    this.maxAttempts = attempts;</span>
<span class="nc" id="L298">    return this;</span>
  }

  /** Set to true if the error is one that can be retried. */
  public HttpLogEntry withCanRetry(boolean retry) {
<span class="nc" id="L303">    this.canRetry = retry;</span>
<span class="nc" id="L304">    return this;</span>
  }

  /** Set the exception if there is a failure such as a connect timeout. */
  public HttpLogEntry withException(Throwable t) {
<span class="nc" id="L309">    exception = t;</span>
<span class="nc" id="L310">    return this;</span>
  }

  /** Set the status code from the response. */
  public HttpLogEntry withStatusCode(int code) {
<span class="nc" id="L315">    this.statusCode = code;</span>
<span class="nc" id="L316">    return this;</span>
  }

  /** Set the status reason from the response. */
  public HttpLogEntry withStatusReason(String reason) {
<span class="nc" id="L321">    this.statusReason = reason;</span>
<span class="nc" id="L322">    return this;</span>
  }

  /** Add a header that was on the response. */
  public HttpLogEntry withResponseHeader(String name, String value) {
<span class="nc" id="L327">    responseHeaders.add(new Header(name, value));</span>
<span class="nc" id="L328">    return this;</span>
  }

  /** Set the content-length from the response. */
  public HttpLogEntry withResponseContentLength(long size) {
<span class="nc" id="L333">    this.responseContentLength = size;</span>
<span class="nc" id="L334">    return this;</span>
  }

  /** Set the latency for the request. */
  public HttpLogEntry withRequestLatency(long t) {
<span class="nc" id="L339">    this.latency = t;</span>
<span class="nc" id="L340">    return this;</span>
  }

  /** Mark the time an event occurred. Should include at least the start and end of a request. */
  public HttpLogEntry mark(String name) {
<span class="nc" id="L345">    events.add(new Event(name, System.currentTimeMillis()));</span>
<span class="nc" id="L346">    return this;</span>
  }

  /** Mark the time an event occurred. Should include at least the start and end of a request. */
  public HttpLogEntry mark(String name, long timestamp) {
<span class="nc" id="L351">    events.add(new Event(name, timestamp));</span>
<span class="nc" id="L352">    return this;</span>
  }

  /** Return the request id. */
  public String getRequestId() {
<span class="nc" id="L357">    return requestId;</span>
  }

  /** Return the attempt id. */
  public String getAttemptId() {
<span class="nc" id="L362">    return attemptId;</span>
  }

  /**
   * Return the latency for the request. If not explicitly set it will be calculated from the
   * events.
   */
  public long getLatency() {
<span class="nc bnc" id="L370" title="All 2 branches missed.">    if (latency &gt;= 0L) {</span>
<span class="nc" id="L371">      return latency;</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">    } else if (events.size() &gt;= 2) {</span>
<span class="nc" id="L373">      return events.get(events.size() - 1).timestamp() - events.get(0).timestamp();</span>
    } else {
<span class="nc" id="L375">      return -1;</span>
    }
  }

  /** Return the overall latency for a group of requests including all retries. */
  public long getOverallLatency() {
<span class="nc bnc" id="L381" title="All 4 branches missed.">    if (maxAttempts &lt;= 1 || originalStart &lt; 0) {</span>
<span class="nc" id="L382">      return getLatency();</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">    } else if (events.isEmpty()) {</span>
<span class="nc" id="L384">      return -1;</span>
    } else {
<span class="nc" id="L386">      return events.get(events.size() - 1).timestamp() - originalStart;</span>
    }
  }

  /** Return the starting time for the request. */
  public String getStartTime() {
<span class="nc bnc" id="L392" title="All 2 branches missed.">    return events.isEmpty()</span>
        ? &quot;unknown&quot;
<span class="nc" id="L394">        : isoDate.format(new Date(events.get(0).timestamp()));</span>
  }

  private int getHeadersLength(List&lt;Header&gt; headers) {
<span class="nc" id="L398">    int size = 0;</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">    for (Header h : headers) {</span>
<span class="nc" id="L400">      size += h.numBytes();</span>
<span class="nc" id="L401">    }</span>
<span class="nc" id="L402">    return size;</span>
  }

  /** Return the size in bytes of all request headers. */
  public int getRequestHeadersLength() {
<span class="nc" id="L407">    return getHeadersLength(requestHeaders);</span>
  }

  /** Return the size in bytes of all response headers. */
  public int getResponseHeadersLength() {
<span class="nc" id="L412">    return getHeadersLength(responseHeaders);</span>
  }

  /** Return a time line based on marked events. */
  public String getTimeline() {
<span class="nc" id="L417">    StringBuilder builder = new StringBuilder();</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">    for (Event event : events) {</span>
<span class="nc" id="L419">      builder.append(event.name()).append(&quot;:&quot;).append(event.timestamp()).append(&quot;;&quot;);</span>
<span class="nc" id="L420">    }</span>
<span class="nc" id="L421">    return builder.toString();</span>
  }

  private String getExceptionClass() {
<span class="nc bnc" id="L425" title="All 2 branches missed.">    return (exception == null)</span>
        ? &quot;null&quot;
<span class="nc" id="L427">        : exception.getClass().getName();</span>
  }

  private String getExceptionMessage() {
<span class="nc bnc" id="L431" title="All 2 branches missed.">    return (exception == null)</span>
        ? &quot;null&quot;
<span class="nc" id="L433">        : exception.getMessage();</span>
  }

  private String getHeaders(List&lt;Header&gt; headers) {
<span class="nc" id="L437">    StringBuilder builder = new StringBuilder();</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">    for (Header h : headers) {</span>
<span class="nc" id="L439">      builder.append(h.name()).append(':').append(h.value()).append(';');</span>
<span class="nc" id="L440">    }</span>
<span class="nc" id="L441">    return builder.toString();</span>
  }

  /** Return a summary of all request headers. */
  public String getRequestHeaders() {
<span class="nc" id="L446">    return getHeaders(requestHeaders);</span>
  }

  /** Return a summary of all response headers. */
  public String getResponseHeaders() {
<span class="nc" id="L451">    return getHeaders(responseHeaders);</span>
  }

  private String getStatusTag() {
<span class="nc bnc" id="L455" title="All 2 branches missed.">    return (exception != null)</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">        ? exception.getClass().getSimpleName()</span>
        : (statusCode &gt;= 100 ? (statusCode / 100) + &quot;xx&quot; : &quot;unknown&quot;);
  }

  private String getStatusCodeTag() {
<span class="nc bnc" id="L461" title="All 2 branches missed.">    return (exception != null)</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">        ? exception.getClass().getSimpleName()</span>
        : (statusCode &gt;= 100 ? &quot;&quot; + statusCode : &quot;unknown&quot;);
  }

  @Override public String toString() {
<span class="nc" id="L467">    return new StringBuilder()</span>
<span class="nc" id="L468">        .append(clientName).append('\t')</span>
<span class="nc" id="L469">        .append(getStartTime()).append('\t')</span>
<span class="nc" id="L470">        .append(getLatency()).append('\t')</span>
<span class="nc" id="L471">        .append(getOverallLatency()).append('\t')</span>
<span class="nc" id="L472">        .append(getTimeline()).append('\t')</span>
<span class="nc" id="L473">        .append(method).append('\t')</span>
<span class="nc" id="L474">        .append(originalUri).append('\t')</span>
<span class="nc" id="L475">        .append(requestUri).append('\t')</span>
<span class="nc" id="L476">        .append(remoteAddr).append('\t')</span>
<span class="nc" id="L477">        .append(remotePort).append('\t')</span>
<span class="nc" id="L478">        .append(statusCode).append('\t')</span>
<span class="nc" id="L479">        .append(statusReason).append('\t')</span>
<span class="nc" id="L480">        .append(getExceptionClass()).append('\t')</span>
<span class="nc" id="L481">        .append(getExceptionMessage()).append('\t')</span>
<span class="nc" id="L482">        .append(getRequestHeadersLength()).append('\t')</span>
<span class="nc" id="L483">        .append(requestContentLength).append('\t')</span>
<span class="nc" id="L484">        .append(getResponseHeadersLength()).append('\t')</span>
<span class="nc" id="L485">        .append(responseContentLength).append('\t')</span>
<span class="nc" id="L486">        .append(getRequestHeaders()).append('\t')</span>
<span class="nc" id="L487">        .append(getResponseHeaders()).append('\t')</span>
<span class="nc" id="L488">        .append(redirect).append('\t')</span>
<span class="nc" id="L489">        .append(attempt).append('\t')</span>
<span class="nc" id="L490">        .append(maxAttempts)</span>
<span class="nc" id="L491">        .toString();</span>
  }

  private static class Header {
    private final String name;
    private final String value;

<span class="nc" id="L498">    Header(String name, String value) {</span>
<span class="nc" id="L499">      this.name = name;</span>
<span class="nc" id="L500">      this.value = value;</span>
<span class="nc" id="L501">    }</span>

    String name() {
<span class="nc" id="L504">      return name;</span>
    }

    String value() {
<span class="nc" id="L508">      return value;</span>
    }

    int numBytes() {
<span class="nc" id="L512">      return name.length() + &quot;: &quot;.length() + value.length() + &quot;\n&quot; .length();</span>
    }
  }

<span class="nc" id="L516">  private static class Event {</span>
    private final String name;
    private final long timestamp;

<span class="nc" id="L520">    Event(String name, long timestamp) {</span>
<span class="nc" id="L521">      this.name = name;</span>
<span class="nc" id="L522">      this.timestamp = timestamp;</span>
<span class="nc" id="L523">    }</span>

    String name() {
<span class="nc" id="L526">      return name;</span>
    }

    long timestamp() {
<span class="nc" id="L530">      return timestamp;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>
{
    "docs": [
        {
            "location": "/", 
            "text": "Simple library for instrumenting code to record dimensional time series. If\nyou are new to the library it is highly recommended to read the pages in the\n\nGetting Started\n section on the sidebar.\n\n\nAt a minimum you will need to:\n\n\n\n\nDepend on the api library. It is in maven central, for gradle the dependency\n   would be \ncom.netflix.spectator:spectator-api:0.38.0\n.\n\n\nInstrument some code, see the usage guides for \ncounters\n,\n   \ntimers\n, and \ngauges\n.\n\n\nPick a registry to bind to when initializing the application. See the sidebar\n   for a list of available registries.", 
            "title": "Home"
        }, 
        {
            "location": "/intro/counter/", 
            "text": "Counters\n\n\nA counter is used to measure the rate at which some event is occurring.\nConsider a simple queue, counters would be used to measure things like the\nrate at which items are being inserted and removed. \n\n\nCounters are created using the registry which will be setup as part of\napplication initialization. For example:\n\n\npublic class Queue {\n\n  private final Counter insertCounter;\n  private final Counter removeCounter;\n  private final QueueImpl impl;\n\n  @Inject\n  public Queue(Registry registry) {\n    insertCounter = registry.counter(\nqueue.insert\n);\n    removeCounter = registry.counter(\nqueue.remove\n);\n    impl = new QueueImpl();\n  }\n\n\n\n\nThen call increment when an event occurs:\n\n\n  public void insert(Object obj) {\n    insertCounter.increment();\n    impl.insert(obj);\n  }\n\n  public Object remove() {\n    if (impl.nonEmpty()) {\n      removeCounter.increment();\n      return impl.remove();\n    } else {\n      return null;\n    }\n  }\n\n\n\n\nOptionally an amount can be passed in when calling increment. This is useful\nwhen a collection of events happens together. \n\n\n  public void insertAll(Collection\nObject\n objs) {\n    insertCounter.increment(objs.size());\n    impl.insertAll(objs);\n  }\n}", 
            "title": "Counters"
        }, 
        {
            "location": "/intro/counter/#counters", 
            "text": "A counter is used to measure the rate at which some event is occurring.\nConsider a simple queue, counters would be used to measure things like the\nrate at which items are being inserted and removed.   Counters are created using the registry which will be setup as part of\napplication initialization. For example:  public class Queue {\n\n  private final Counter insertCounter;\n  private final Counter removeCounter;\n  private final QueueImpl impl;\n\n  @Inject\n  public Queue(Registry registry) {\n    insertCounter = registry.counter( queue.insert );\n    removeCounter = registry.counter( queue.remove );\n    impl = new QueueImpl();\n  }  Then call increment when an event occurs:    public void insert(Object obj) {\n    insertCounter.increment();\n    impl.insert(obj);\n  }\n\n  public Object remove() {\n    if (impl.nonEmpty()) {\n      removeCounter.increment();\n      return impl.remove();\n    } else {\n      return null;\n    }\n  }  Optionally an amount can be passed in when calling increment. This is useful\nwhen a collection of events happens together.     public void insertAll(Collection Object  objs) {\n    insertCounter.increment(objs.size());\n    impl.insertAll(objs);\n  }\n}", 
            "title": "Counters"
        }, 
        {
            "location": "/intro/timer/", 
            "text": "Timers\n\n\nA timer is used to measure how long some event is taking. Two types of timers\nare supported:\n\n\n\n\nTimer\n: for frequent short duration events.\n\n\nLongTaskTimer\n: for long running tasks.\n\n\n\n\nThe long duration timer is setup so that you can track the time while an\nevent being measured is still running. A regular timer just records the\nduration and has no information until the task is complete.\n\n\nAs an example, consider a chart showing request latency to a typical web\nserver. The expectation is many short requests so the timer will be getting\nupdated many times per second.\n\n\n\n\nNow consider a background process to refresh metadata from a data store. For\nexample, Edda caches AWS resources such as instances, volumes, auto-scaling\ngroups etc. Normally all data can be refreshed in a few minutes. If the AWS\nservices are having problems it can take much longer. A long duration timer\ncan be used to track the overall time for refreshing the metadata.\n\n\nThe charts below show max latency for the refresh using a regular timer and\na long task timer. Regular timer, note that the y-axis is using a logarithmic\nscale:\n\n\n\n\nLong task timer:\n\n\n\n\nTimer\n\n\nTo get started create an instance using the registry:\n\n\npublic class Server {\n\n  private final Registry registry;\n  private final Timer requestLatency;\n\n  @Inject\n  public Server(Registry registry) {\n    this.registry = registry;\n    requestLatency = registry.timer(\nserver.requestLatency\n);\n  }\n\n\n\n\nThen wrap the call you need to measure:\n\n\n  public Response handle(Request request) {\n    final long start = registry.clock().monotonicTime();\n    try {\n      return handleImpl(request);\n    } finally {\n      final long end = registry.clock().monotonicTime();\n      requestLatency.record(end - start, TimeUnit.NANOSECONDS);\n    }\n  }\n\n\n\n\nThis example uses the clock from the registry which can be useful for\ntesting if you need to control the timing. In actual usage it will typically\nget mapped to the system clock. It is recommended to use a monotonically\nincreasing source for measuring the times to avoid occasionally having bogus\nmeasurements due to time adjustments. For more information see the\n\nClock documentation\n.\n\n\nAlso note that the record call is done in a finally block to ensure that\nthe time will get recorded if a failure occurs. The example above could have\nalso been done using a lambda:\n\n\n  public Response handle(Request request) {\n    return requestLatency.record(() -\n handleImpl(request));\n  }\n\n\n\n\nLongTaskTimer\n\n\nTo get started create an instance using the registry:\n\n\npublic class MetadataService {\n\n  private final LongTaskTimer metadataRefresh;\n\n  @Inject\n  public MetadataService(Registry registry) {\n    metadataRefresh = registry.longTaskTimer(\nmetadata.refreshDuration\n);\n    // setup background thread to call refresh()\n  }\n\n  private void refresh() {\n    final int id = metadataRefresh.start();\n    try {\n      refreshImpl();\n    } finally {\n      metadataRefresh.stop(id);\n    }\n  }\n\n\n\n\nThe id is used to keep track of a particular task being measured by the timer.\nIt must be stopped using the provided id. Note that unlike a regular timer\nthat does not do anything until the final duration is recorded, a long duration\ntimer will report as two gauges:\n\n\n\n\nduration\n: total duration spent within all currently running tasks.\n\n\nactiveTasks\n: number of currently running tasks.\n\n\n\n\nThis means that you can see what is happening while the task is running, but\nyou need to keep in mind:\n\n\n\n\nThe id is fixed before the task begins. There is no way to change tags based\n  on the run, e.g., update a different timer if an exception is thrown.\n\n\nBeing a guage it is inappropriate for short tasks. In particular, gauges are\n  sampled and if it is not sampled during the execution or the sampling period\n  is a significant subset of the expected duration, then the duration value\n  will not be meaningful.\n\n\n\n\nLike a regular timer, the duration timer also supports using a lambda to\nsimplify the common case:\n\n\n  private void refresh() {\n    metadataRefresh.record(this::refreshImpl);\n  }", 
            "title": "Timers"
        }, 
        {
            "location": "/intro/timer/#timers", 
            "text": "A timer is used to measure how long some event is taking. Two types of timers\nare supported:   Timer : for frequent short duration events.  LongTaskTimer : for long running tasks.   The long duration timer is setup so that you can track the time while an\nevent being measured is still running. A regular timer just records the\nduration and has no information until the task is complete.  As an example, consider a chart showing request latency to a typical web\nserver. The expectation is many short requests so the timer will be getting\nupdated many times per second.   Now consider a background process to refresh metadata from a data store. For\nexample, Edda caches AWS resources such as instances, volumes, auto-scaling\ngroups etc. Normally all data can be refreshed in a few minutes. If the AWS\nservices are having problems it can take much longer. A long duration timer\ncan be used to track the overall time for refreshing the metadata.  The charts below show max latency for the refresh using a regular timer and\na long task timer. Regular timer, note that the y-axis is using a logarithmic\nscale:   Long task timer:", 
            "title": "Timers"
        }, 
        {
            "location": "/intro/timer/#timer", 
            "text": "To get started create an instance using the registry:  public class Server {\n\n  private final Registry registry;\n  private final Timer requestLatency;\n\n  @Inject\n  public Server(Registry registry) {\n    this.registry = registry;\n    requestLatency = registry.timer( server.requestLatency );\n  }  Then wrap the call you need to measure:    public Response handle(Request request) {\n    final long start = registry.clock().monotonicTime();\n    try {\n      return handleImpl(request);\n    } finally {\n      final long end = registry.clock().monotonicTime();\n      requestLatency.record(end - start, TimeUnit.NANOSECONDS);\n    }\n  }  This example uses the clock from the registry which can be useful for\ntesting if you need to control the timing. In actual usage it will typically\nget mapped to the system clock. It is recommended to use a monotonically\nincreasing source for measuring the times to avoid occasionally having bogus\nmeasurements due to time adjustments. For more information see the Clock documentation .  Also note that the record call is done in a finally block to ensure that\nthe time will get recorded if a failure occurs. The example above could have\nalso been done using a lambda:    public Response handle(Request request) {\n    return requestLatency.record(() -  handleImpl(request));\n  }", 
            "title": "Timer"
        }, 
        {
            "location": "/intro/timer/#longtasktimer", 
            "text": "To get started create an instance using the registry:  public class MetadataService {\n\n  private final LongTaskTimer metadataRefresh;\n\n  @Inject\n  public MetadataService(Registry registry) {\n    metadataRefresh = registry.longTaskTimer( metadata.refreshDuration );\n    // setup background thread to call refresh()\n  }\n\n  private void refresh() {\n    final int id = metadataRefresh.start();\n    try {\n      refreshImpl();\n    } finally {\n      metadataRefresh.stop(id);\n    }\n  }  The id is used to keep track of a particular task being measured by the timer.\nIt must be stopped using the provided id. Note that unlike a regular timer\nthat does not do anything until the final duration is recorded, a long duration\ntimer will report as two gauges:   duration : total duration spent within all currently running tasks.  activeTasks : number of currently running tasks.   This means that you can see what is happening while the task is running, but\nyou need to keep in mind:   The id is fixed before the task begins. There is no way to change tags based\n  on the run, e.g., update a different timer if an exception is thrown.  Being a guage it is inappropriate for short tasks. In particular, gauges are\n  sampled and if it is not sampled during the execution or the sampling period\n  is a significant subset of the expected duration, then the duration value\n  will not be meaningful.   Like a regular timer, the duration timer also supports using a lambda to\nsimplify the common case:    private void refresh() {\n    metadataRefresh.record(this::refreshImpl);\n  }", 
            "title": "LongTaskTimer"
        }, 
        {
            "location": "/intro/gauge/", 
            "text": "Gauges\n\n\nA gauge is a handle to get the current value. Typical examples for gauges\nwould be the size of a queue or number of threads in the running state.\nSince gauges are sampled, there is no information about what might have\noccurred between samples.\n\n\nConsider monitoring the behavior of a queue of tasks. If the data is being\ncollected once a minute, then a gauge for the size will show the size when\nit was sampled. The size may have been much higher or lower at some point\nduring interval, but that is not known.\n\n\nRegistration\n\n\nA gauge is registered by passing in an id, a reference to the object, and\na function to get or compute a numeric value based on the object. The\nreference to the object is passed in separately and the spectator registry\nwill keep a weak reference to the object. If the object is garbage collected,\nthen it will automatically drop the registration.\n\n\nWhen multiple gauges are registered with the same id the reported value will\nbe the sum of the matches.\n\n\nUsing Lambda\n\n\nSpecify a lambda that takes the object as parameter.\n\n\npublic class Queue {\n\n  @Inject\n  public Queue(Registry registry) {\n    registry.gauge(\nqueue.size\n, this, Queue::size);\n  }\n\n  ...\n}\n\n\n\n\n\n\nWarning\n\n\nBe careful to avoid creating a reference to the object in the\nlambda. It will prevent garbage collection and can lead to a memory leak\nin the application. For example, by calling size without using the passed\nin object there will be a reference to \nthis\n:\n\n\nregistry.gauge(\"queue.size\", this, obj -\n size());\n\n\n\n\nUsing Reflection\n\n\nUse reflection to call a method on an object. The method must have an empty\nparameter list and return a number. This approach can be used to access\nmethods that are not public.\n\n\npublic class Queue {\n\n  @Inject\n  public Queue(Registry registry) {\n    registry.methodValue(\nqueue.size\n, this, \nsize\n);\n  }\n\n  ...\n}\n\n\n\n\nUsing Number\n\n\nA gauge can also be created based on an implementation of Number. For example:\n\n\nAtomicInteger size = new AtomicInteger();\nregistry.gauge(\nqueue.size\n, size);\n\n\n\n\nThe call will return the Number so the registration can be inline on the\nassignment:\n\n\nAtomicInteger size = registry.gauge(\nqueue.size\n, new AtomicInteger());\n\n\n\n\nCollection Sizes\n\n\nFor classes that implement \nCollection\n or \nMap\n there are helpers:\n\n\nQueue queue = new LinkedBlockingQueue();\nregistry.collectionSize(\nqueue.size\n, queue);\n\nMap\nString, String\n cache = new ConcurrentMap\n();\nregistry.mapSize(\ncache.size\n, cache);", 
            "title": "Gauges"
        }, 
        {
            "location": "/intro/gauge/#gauges", 
            "text": "A gauge is a handle to get the current value. Typical examples for gauges\nwould be the size of a queue or number of threads in the running state.\nSince gauges are sampled, there is no information about what might have\noccurred between samples.  Consider monitoring the behavior of a queue of tasks. If the data is being\ncollected once a minute, then a gauge for the size will show the size when\nit was sampled. The size may have been much higher or lower at some point\nduring interval, but that is not known.", 
            "title": "Gauges"
        }, 
        {
            "location": "/intro/gauge/#registration", 
            "text": "A gauge is registered by passing in an id, a reference to the object, and\na function to get or compute a numeric value based on the object. The\nreference to the object is passed in separately and the spectator registry\nwill keep a weak reference to the object. If the object is garbage collected,\nthen it will automatically drop the registration.  When multiple gauges are registered with the same id the reported value will\nbe the sum of the matches.", 
            "title": "Registration"
        }, 
        {
            "location": "/intro/gauge/#using-lambda", 
            "text": "Specify a lambda that takes the object as parameter.  public class Queue {\n\n  @Inject\n  public Queue(Registry registry) {\n    registry.gauge( queue.size , this, Queue::size);\n  }\n\n  ...\n}   Warning  Be careful to avoid creating a reference to the object in the\nlambda. It will prevent garbage collection and can lead to a memory leak\nin the application. For example, by calling size without using the passed\nin object there will be a reference to  this :  registry.gauge(\"queue.size\", this, obj -  size());", 
            "title": "Using Lambda"
        }, 
        {
            "location": "/intro/gauge/#using-reflection", 
            "text": "Use reflection to call a method on an object. The method must have an empty\nparameter list and return a number. This approach can be used to access\nmethods that are not public.  public class Queue {\n\n  @Inject\n  public Queue(Registry registry) {\n    registry.methodValue( queue.size , this,  size );\n  }\n\n  ...\n}", 
            "title": "Using Reflection"
        }, 
        {
            "location": "/intro/gauge/#using-number", 
            "text": "A gauge can also be created based on an implementation of Number. For example:  AtomicInteger size = new AtomicInteger();\nregistry.gauge( queue.size , size);  The call will return the Number so the registration can be inline on the\nassignment:  AtomicInteger size = registry.gauge( queue.size , new AtomicInteger());", 
            "title": "Using Number"
        }, 
        {
            "location": "/intro/gauge/#collection-sizes", 
            "text": "For classes that implement  Collection  or  Map  there are helpers:  Queue queue = new LinkedBlockingQueue();\nregistry.collectionSize( queue.size , queue);\n\nMap String, String  cache = new ConcurrentMap ();\nregistry.mapSize( cache.size , cache);", 
            "title": "Collection Sizes"
        }, 
        {
            "location": "/intro/dist-summary/", 
            "text": "Distribution Summaries\n\n\nA distribution summary is used to track the distribution of events. It is\nsimilar to a timer, but more general in that the size does not have to be\na period of time. For example, a distribution summary could be used to measure\nthe payload sizes of requests hitting a server.\n\n\nIt is recommended to always use base units when recording the data. So if\nmeasuring the payload size use bytes, not kilobytes or some other unit.\n\n\nDistribution summaries are created using the registry which will be setup as\npart of application initialization. For example:\n\n\npublic class Server {\n\n  private final DistributionSummary requestSize;\n\n  @Inject\n  public Server(Registry registry) {\n    requestSize = registry.distributionSummary(\nserver.requestSize\n);\n  }\n\n\n\n\nThen call record when an event occurs:\n\n\n  public Response handle(Request request) {\n    requestSize.record(request.sizeInBytes());\n  }\n}", 
            "title": "Distribution Summaries"
        }, 
        {
            "location": "/intro/dist-summary/#distribution-summaries", 
            "text": "A distribution summary is used to track the distribution of events. It is\nsimilar to a timer, but more general in that the size does not have to be\na period of time. For example, a distribution summary could be used to measure\nthe payload sizes of requests hitting a server.  It is recommended to always use base units when recording the data. So if\nmeasuring the payload size use bytes, not kilobytes or some other unit.  Distribution summaries are created using the registry which will be setup as\npart of application initialization. For example:  public class Server {\n\n  private final DistributionSummary requestSize;\n\n  @Inject\n  public Server(Registry registry) {\n    requestSize = registry.distributionSummary( server.requestSize );\n  }  Then call record when an event occurs:    public Response handle(Request request) {\n    requestSize.record(request.sizeInBytes());\n  }\n}", 
            "title": "Distribution Summaries"
        }, 
        {
            "location": "/intro/conventions/", 
            "text": "Quick summary:\n\n\n\n\nNames\n\n\nDescribe the measurement being collected\n\n\nUse camel case\n\n\nStatic\n\n\nSuccinct\n\n\n\n\n\n\nTags\n\n\nShould be used for dimensional drill-down\n\n\nBe careful about combinatorial explosion\n\n\nTag keys should be static\n\n\nUse \nid\n to distinguish between instances\n\n\n\n\n\n\nUse base units\n\n\n\n\nNames\n\n\nDescribe the measurement\n\n\nUse camel case\n\n\nThe main goal here is to promote consistency which makes it easier for users. The choice of\nstyle is somewhat arbitrary, camel case was chosen because:\n\n\n\n\nUsed by snmp\n\n\nUsed by java\n\n\nIt was the most common in use at Netflix when this guideline was added\n\n\n\n\nThe exception to this rule is where there is an established common case. For example with\nAmazon regions it is preferred to use us-east-1 rather than usEast1 as it is the more common\nform.\n\n\nStatic\n\n\nThere shouldn't be any dynamic content that goes into a metric name. Metric names and\nassociated tag keys are how users will interact with the data being produced. \n\n\nSuccinct\n\n\nLong names should be avoided. \n\n\nTags\n\n\nHistorically tags have been used to play one of two roles:\n\n\n\n\nDimensions\n: dimensions are the primary use and it allows the data to be sliced and diced so\n  it is possible to drill down into the data.\n\n\nNamespace\n: similar to packages in Java in this mode it would be used to group related data.\n  This type of usage is discouraged.   \n\n\n\n\nAs a general rule it should be possible to use the name as a pivot. This means that if\njust the name is selected, then the user can drill down using other dimensions and be\nable to reason about the value being shown. \n\n\nAs a concrete example, suppose we have two metrics:\n\n\n\n\nThe number of threads currently in a thread pool.\n\n\nThe number of rows in a database table.\n\n\n\n\nBad approach\n\n\nId poolSize = registry.createId(\nsize\n)\n  .withTag(\nclass\n, \nThreadPool\n)\n  .withTag(\nid\n, \nserver-requests\n);\n\nId poolSize = registry.createId(\nsize\n)\n  .withTag(\nclass\n, \nDatabase\n)\n  .withTag(\ntable\n, \nusers\n);  \n\n\n\n\nIn this approach, if I select the name, \nsize\n, it will match both the version for \nThreadPool and Database classes. So you would get a value that is the an aggregate of the number\nof threads and the number of items in a database. \n\n\nRecommended\n\n\nId poolSize = registry.createId(\nthreadpool.size\n)\n  .withTag(\nid\n, \nserver-requests\n);\n\nId poolSize = registry.createId(\ndb.size\n)\n  .withTag(\ntable\n, \nusers\n);  \n\n\n\n\nThis variant provides enough context so that if just the name is selected the value can\nbe reasoned about and is at least potentially meaningful. For example if I select\n\nthreadpool.size\n I can see the total number of threads in all pools. Then I can group by or\nselect an \nid\n to drill down further.\n\n\nUse base units\n\n\nKeep measurements in base units where possible. For example I would rather have all timers\nin seconds, disk sizes should be bytes, or network rates should be bytes/second. The reason\nis that for my uses this usually means the unit is obvious from the name. It also means the\nSI prefix shown on the graph images make more sense, e.g. 1k is 1 kilobyte not 1 kilo-megabyte.", 
            "title": "Naming Conventions"
        }, 
        {
            "location": "/intro/conventions/#names", 
            "text": "", 
            "title": "Names"
        }, 
        {
            "location": "/intro/conventions/#describe-the-measurement", 
            "text": "", 
            "title": "Describe the measurement"
        }, 
        {
            "location": "/intro/conventions/#use-camel-case", 
            "text": "The main goal here is to promote consistency which makes it easier for users. The choice of\nstyle is somewhat arbitrary, camel case was chosen because:   Used by snmp  Used by java  It was the most common in use at Netflix when this guideline was added   The exception to this rule is where there is an established common case. For example with\nAmazon regions it is preferred to use us-east-1 rather than usEast1 as it is the more common\nform.", 
            "title": "Use camel case"
        }, 
        {
            "location": "/intro/conventions/#static", 
            "text": "There shouldn't be any dynamic content that goes into a metric name. Metric names and\nassociated tag keys are how users will interact with the data being produced.", 
            "title": "Static"
        }, 
        {
            "location": "/intro/conventions/#succinct", 
            "text": "Long names should be avoided.", 
            "title": "Succinct"
        }, 
        {
            "location": "/intro/conventions/#tags", 
            "text": "Historically tags have been used to play one of two roles:   Dimensions : dimensions are the primary use and it allows the data to be sliced and diced so\n  it is possible to drill down into the data.  Namespace : similar to packages in Java in this mode it would be used to group related data.\n  This type of usage is discouraged.      As a general rule it should be possible to use the name as a pivot. This means that if\njust the name is selected, then the user can drill down using other dimensions and be\nable to reason about the value being shown.   As a concrete example, suppose we have two metrics:   The number of threads currently in a thread pool.  The number of rows in a database table.", 
            "title": "Tags"
        }, 
        {
            "location": "/intro/conventions/#bad-approach", 
            "text": "Id poolSize = registry.createId( size )\n  .withTag( class ,  ThreadPool )\n  .withTag( id ,  server-requests );\n\nId poolSize = registry.createId( size )\n  .withTag( class ,  Database )\n  .withTag( table ,  users );    In this approach, if I select the name,  size , it will match both the version for \nThreadPool and Database classes. So you would get a value that is the an aggregate of the number\nof threads and the number of items in a database.", 
            "title": "Bad approach"
        }, 
        {
            "location": "/intro/conventions/#recommended", 
            "text": "Id poolSize = registry.createId( threadpool.size )\n  .withTag( id ,  server-requests );\n\nId poolSize = registry.createId( db.size )\n  .withTag( table ,  users );    This variant provides enough context so that if just the name is selected the value can\nbe reasoned about and is at least potentially meaningful. For example if I select threadpool.size  I can see the total number of threads in all pools. Then I can group by or\nselect an  id  to drill down further.", 
            "title": "Recommended"
        }, 
        {
            "location": "/intro/conventions/#use-base-units", 
            "text": "Keep measurements in base units where possible. For example I would rather have all timers\nin seconds, disk sizes should be bytes, or network rates should be bytes/second. The reason\nis that for my uses this usually means the unit is obvious from the name. It also means the\nSI prefix shown on the graph images make more sense, e.g. 1k is 1 kilobyte not 1 kilo-megabyte.", 
            "title": "Use base units"
        }, 
        {
            "location": "/intro/testing/", 
            "text": "Testing\n\n\nTesting should be relatively straightforward if you are using injection for the registry.\nConsider a sample class:\n\n\npublic class Foo {\n\n  private final Counter counter;\n\n  @Inject\n  public Foo(Registry registry) {\n    counter = registry.counter(\nfoo\n);\n  }\n\n  public void doSomething() {\n    counter.increment();\n  }\n}\n\n\n\n\nTests will typically want to use an isolated instance of the \nDefaultRegistry\n.\n\n\nSimple Test\n\n\nA basic standalone test class would look something like:\n\n\npublic class FooTest {\n\n  private Registry registry;\n  private Foo foo;\n\n  @Before\n  public void init() {\n    registry = new DefaultRegistry();\n    foo = new Foo(registry);\n  }\n\n  @Test\n  public void doSomething() {\n    foo.doSomething();\n    Assert.assertEquals(1, registry.counter(\nfoo\n).count());\n  }\n}\n\n\n\n\nGuice Test\n\n\nIf using guice, then the \nTestModule\n can be used:\n\n\npublic class FooTest {\n\n  private Registry registry;\n  private Foo foo;\n\n  @Before\n  public void init() {\n    Injector injector = Guice.createInjector(new TestModule());\n    registry = injector.getInstance(Registry.class);\n    foo = injector.getInstance(Foo.class);\n  }\n\n  @Test\n  public void doSomething() {\n    foo.doSomething();\n    Assert.assertEquals(1, registry.counter(\nfoo\n).count());\n  }\n}\n\n\n\n\nExceptions\n\n\nBy default, for most user errors Spectator will log a warning rather than throw an exception.\nThe rationale is that users do not often think about instrumentation and logging code causing\nan exception and interrupting the control flow of a program. However, for test cases it is\nrecommended to be more aggressive and learn about problems as early as possible. This can\nbe done by setting a system property:\n\n\nspectator.api.propagateWarnings=true\n\n\n\n\nConsider an example:\n\n\nprivate static final Id RARE_EXCEPTION_ID = null;\n\npublic void doSomethingImportant() {\n  try {\n    ... do work ...\n  } catch (RareException e) {\n    // There is a bug in the program, an Id is not allowed to be null. In production we do\n    // not want it to throw and interrupt the control flow. Instrumentation should gracefully\n    // degrade.\n    registry.counter(RARE_EXCEPTION_ID).increment();\n\n    // These statements are important to provide context for operating the system\n    // and to ensure the app continues to function properly.\n    LOGGER.error(\nimportant context for user\n, e);\n    properlyHandleException(e);\n  }\n}", 
            "title": "Testing"
        }, 
        {
            "location": "/intro/testing/#testing", 
            "text": "Testing should be relatively straightforward if you are using injection for the registry.\nConsider a sample class:  public class Foo {\n\n  private final Counter counter;\n\n  @Inject\n  public Foo(Registry registry) {\n    counter = registry.counter( foo );\n  }\n\n  public void doSomething() {\n    counter.increment();\n  }\n}  Tests will typically want to use an isolated instance of the  DefaultRegistry .", 
            "title": "Testing"
        }, 
        {
            "location": "/intro/testing/#simple-test", 
            "text": "A basic standalone test class would look something like:  public class FooTest {\n\n  private Registry registry;\n  private Foo foo;\n\n  @Before\n  public void init() {\n    registry = new DefaultRegistry();\n    foo = new Foo(registry);\n  }\n\n  @Test\n  public void doSomething() {\n    foo.doSomething();\n    Assert.assertEquals(1, registry.counter( foo ).count());\n  }\n}", 
            "title": "Simple Test"
        }, 
        {
            "location": "/intro/testing/#guice-test", 
            "text": "If using guice, then the  TestModule  can be used:  public class FooTest {\n\n  private Registry registry;\n  private Foo foo;\n\n  @Before\n  public void init() {\n    Injector injector = Guice.createInjector(new TestModule());\n    registry = injector.getInstance(Registry.class);\n    foo = injector.getInstance(Foo.class);\n  }\n\n  @Test\n  public void doSomething() {\n    foo.doSomething();\n    Assert.assertEquals(1, registry.counter( foo ).count());\n  }\n}", 
            "title": "Guice Test"
        }, 
        {
            "location": "/intro/testing/#exceptions", 
            "text": "By default, for most user errors Spectator will log a warning rather than throw an exception.\nThe rationale is that users do not often think about instrumentation and logging code causing\nan exception and interrupting the control flow of a program. However, for test cases it is\nrecommended to be more aggressive and learn about problems as early as possible. This can\nbe done by setting a system property:  spectator.api.propagateWarnings=true  Consider an example:  private static final Id RARE_EXCEPTION_ID = null;\n\npublic void doSomethingImportant() {\n  try {\n    ... do work ...\n  } catch (RareException e) {\n    // There is a bug in the program, an Id is not allowed to be null. In production we do\n    // not want it to throw and interrupt the control flow. Instrumentation should gracefully\n    // degrade.\n    registry.counter(RARE_EXCEPTION_ID).increment();\n\n    // These statements are important to provide context for operating the system\n    // and to ensure the app continues to function properly.\n    LOGGER.error( important context for user , e);\n    properlyHandleException(e);\n  }\n}", 
            "title": "Exceptions"
        }, 
        {
            "location": "/intro/netflix/", 
            "text": "Netflix Integration\n\n\nWhen running at Netflix, use the \natlas-client\n library to enable transferring the\ninstrumented data to \nAtlas\n. See the appropriate\nsection for the type of project you are working on:\n\n\n\n\nLibraries\n\n\nApplications\n, specifically standalone apps using guice or governator directly.\n\n\nBase Server\n\n\n\n\nLibraries\n\n\nFor libraries, the only dependency that should be needed is:\n\n\ncom.netflix.spectator:spectator-api:0.38.0\n\n\n\n\nThe bindings to integrate internally should be included with the application. In your code,\njust inject a registry, e.g.:\n\n\npublic class Foo {\n  @Inject\n  public Foo(Registry registry) {\n    ...\n  }\n  ...\n}\n\n\n\n\nSee the \ntesting docs\n for more information about creating a binding to use with tests.\n\n\nApplications\n\n\nApplication should include a dependency on the \natlas-client\n plugin:\n\n\nnetflix:atlas-client:latest.release\n\n\n\n\nNote this is an internal only library with configs specific to the Netflix environments. It\nis assumed you are using Nebula so that internal maven repositories are available for your\nbuild. When configuring with governator specify the \nAtlasModule\n:\n\n\nInjector injector = LifecycleInjector.builder()\n    .withModules(new AtlasModule())\n    .build()\n    .createInjector();\n\n\n\n\nThe registry binding will then be available so it can be injected as shown in the\n\nlibraries section\n. The insight libraries do not use any governator or guice\nspecific features. So it is possible to use guice or other dependency injection frameworks\ndirectly with the following caveats:\n\n\n\n\nHowever, some of the libraries do use the\n\n@PostConstruct\n and\n\n@PreDestroy\n annotations\nfor managing lifecycle. Governator adds lifecycle management and many other features on top of\nguice and is the recommended way. For more minimalist support of just the lifecycle annotations\non top of guice see \niep-guice\n.\n\n\nThe bindings and configuration necessary to run correctly with the internal setup are only\nsupported as guice modules. If trying to use some other dependency injection framework, then\nyou will be responsible for either finding a way to leverage the guice module in that framework\nor recreating those bindings and maintaining them as things change. It is not a paved road path.\n\n\n\n\nBase Server\n\n\nIf using \nbase-server\n, then you will get the Spectator and Atlas bindings automatically.\n\n\nAuto Plugin\n\n\n\n\nWarning\n\n\nDeprecated\n: Use of AutoBindSingleton is generally discouraged. It is recommended to\nuse one of the other methods.\n\n\n\n\nIf you are only interested in getting the GC logging, there is a library with an auto-bind\nsingleton that can be used:\n\n\ncom.netflix.spectator:spectator-nflx:0.38.0\n\n\n\n\nAssuming you are using karyon/base-server or governator with \ncom.netflix\n in the list of base\npackages then the plugin should get automatically loaded.", 
            "title": "Netflix Integration"
        }, 
        {
            "location": "/intro/netflix/#netflix-integration", 
            "text": "When running at Netflix, use the  atlas-client  library to enable transferring the\ninstrumented data to  Atlas . See the appropriate\nsection for the type of project you are working on:   Libraries  Applications , specifically standalone apps using guice or governator directly.  Base Server", 
            "title": "Netflix Integration"
        }, 
        {
            "location": "/intro/netflix/#libraries", 
            "text": "For libraries, the only dependency that should be needed is:  com.netflix.spectator:spectator-api:0.38.0  The bindings to integrate internally should be included with the application. In your code,\njust inject a registry, e.g.:  public class Foo {\n  @Inject\n  public Foo(Registry registry) {\n    ...\n  }\n  ...\n}  See the  testing docs  for more information about creating a binding to use with tests.", 
            "title": "Libraries"
        }, 
        {
            "location": "/intro/netflix/#applications", 
            "text": "Application should include a dependency on the  atlas-client  plugin:  netflix:atlas-client:latest.release  Note this is an internal only library with configs specific to the Netflix environments. It\nis assumed you are using Nebula so that internal maven repositories are available for your\nbuild. When configuring with governator specify the  AtlasModule :  Injector injector = LifecycleInjector.builder()\n    .withModules(new AtlasModule())\n    .build()\n    .createInjector();  The registry binding will then be available so it can be injected as shown in the libraries section . The insight libraries do not use any governator or guice\nspecific features. So it is possible to use guice or other dependency injection frameworks\ndirectly with the following caveats:   However, some of the libraries do use the @PostConstruct  and @PreDestroy  annotations\nfor managing lifecycle. Governator adds lifecycle management and many other features on top of\nguice and is the recommended way. For more minimalist support of just the lifecycle annotations\non top of guice see  iep-guice .  The bindings and configuration necessary to run correctly with the internal setup are only\nsupported as guice modules. If trying to use some other dependency injection framework, then\nyou will be responsible for either finding a way to leverage the guice module in that framework\nor recreating those bindings and maintaining them as things change. It is not a paved road path.", 
            "title": "Applications"
        }, 
        {
            "location": "/intro/netflix/#base-server", 
            "text": "If using  base-server , then you will get the Spectator and Atlas bindings automatically.", 
            "title": "Base Server"
        }, 
        {
            "location": "/intro/netflix/#auto-plugin", 
            "text": "Warning  Deprecated : Use of AutoBindSingleton is generally discouraged. It is recommended to\nuse one of the other methods.   If you are only interested in getting the GC logging, there is a library with an auto-bind\nsingleton that can be used:  com.netflix.spectator:spectator-nflx:0.38.0  Assuming you are using karyon/base-server or governator with  com.netflix  in the list of base\npackages then the plugin should get automatically loaded.", 
            "title": "Auto Plugin"
        }, 
        {
            "location": "/intro/servo-comparison/", 
            "text": "Servo Comparison\n\n\nServo\n is an alternative client monitoring\nlibrary that is also developed by Netflix. Originally spectator was an\nexperiment for a simpler API that wrapped servo. It was done as a separate\nproject to avoid breaking backwards compatibility for servo.\n\n\nFrom a user perspective, both will be supported for a long time, but most\nof our efforts for future improvement will go to spectator. For new code it\nis recommended to use the spectator API. If running\n\nat Netflix\n the correct bindings will be in place\nfor both servo and spectator.\n\n\nDifferences\n\n\nThis section provides a quick summary of the differences.\n\n\nSimpler API\n\n\nServo gives the user a lot of control, but this makes it hard to use\ncorrectly. For example, to create a counter the user needs to understand\nthe tradeoffs and choose between:\n\n\n\n\nBasicCounter\n\n\nDynamicCounter\n\n\nContextualCounter\n\n\nStepCounter\n\n\n\n\nFurther each of these can impact how data is reported to observers. The\nspectator API focuses on the constructs a user needs to instrument the\ncode. In spectator the user would always use the registry to create a\n\nCounter\n. The implementation details are left up to the\nregistry.\n\n\nThe \nregistration\n is simpler as well to avoid common pitfalls\nwhen using servo like overwriting a registered object.\n\n\nMore Focused\n\n\nThe goal of spectator is instrumenting code to send to a dimensional\ntime-series system like \nAtlas\n.\nServo has goals of staying compatible with a number of legacy libraries\nand naming formats, exposing data to JMX, etc. Examples of how this\ninfluences decisions:\n\n\n\n\nNo support for non-numeric data. Servo supported this for exposing to JMX.\n  Exposing the numeric data registered in spectator to JMX can be done\n  using a registry that supports it, but there is no goal to be a general\n  interface for exposing arbitrary data in JMX.\n\n\nNo support for customizeable time units when reporting timer data. Base\n  units should always be used for reporting and conversions can be performed\n  in the presentation layer if needed. It also avoids a lot of the confusion\n  around the timer unit for the data and issues like creating aggregates that\n  are meaningless because of mixed units.\n\n\n\n\nIt is better to have a simple way to get correct and easy to reason about\ndata to the backend than many options. If you want more knobs, then you can use\nServo.\n\n\nDI Friendly\n\n\nWhen servo was originally written dependency injection was not heavily used\nat Netflix. Further servo needed to stay compatible with a number of use-cases\nthat were heavily static.\n\n\nWhile spectator does have a static registry that can be used, the recommended\nway is to create a registry and inject it either manually or via a framework\ninto the classes that need it. This also makes it much easier to\n\ntest in isolation\n.\n\n\nMigration\n\n\nIf you want to migrate from the servo API to the spectator API, then this\nsection provides some guides on how servo constructs can be ported over. The\nsub-sections are the class names of monitor types supported by servo.\n\n\nFor users at Netflix, note we are not actively pushing teams to migrate\nor do any additional work. Servo is still supported and if it works for your\nuse-cases feel free to continue using it. \n\n\nRegistration\n\n\nFirst read through the \nservo docs on registration\n.\nIn servo if you have a class like:\n\n\npublic class Foo {\n\n  private AtomicInteger gauge;\n  private Counter counter;\n\n  public Foo(String id) {\n    gauge = new AtomicInteger();\n    counter = new BasicCounter(MonitorConfig.builder(\ncounter\n).build());\n    Monitors.registerObject(id, this);\n  }\n\n  @Monitor(name = \ngauge\n, type = DataSourceType.GAUGE)\n  private int gauge() {\n    return gauge.get();\n  }\n\n  public void doSomething() {\n    ...\n  }\n}\n\n\n\n\nThe state of the class is in the member variables of an instance of \nFoo\n.\nIf multiple instances of class \nFoo\n are created with the same value for \nid\n,\nthen the last one will overwrite the others for the registration. So the\nvalues getting reported will only be from the last instance registered. Also\nthe registry has a reference to the instance of \nFoo\n so it will never go\naway.\n\n\nFor counters and timers one way to get around this is to use\n\nDynamicCounter\n and \nDynamicTimer\n\nrespectively. Those classes will automatically handle the registration and\nexpire if there is no activity. They also get used for cases where the set\nof dimensions is not known up front.\n\n\nGauges need to sample the state of something so they need to have a reference\nto an object that contains the state. So the user would need to ensure that\nonly a single copy was registered leading to patterns like:\n\n\nclass Foo {\n\n  private static class FooStats {\n\n    private AtomicInteger gauge;\n    private Counter counter;\n\n    public FooStats(String id) {\n      gauge = new AtomicInteger();\n      counter = new BasicCounter(MonitorConfig.builder(\ncounter\n).build());\n      Monitors.registerObject(id, this);\n    }\n\n    @Monitor(name = \ngauge\n, type = DataSourceType.GAUGE)\n    private int gauge() {\n      return gauge.get();\n    }\n  }\n\n  private static ConcurrentHashMap\nString, FooStats\n STATS =\n    new ConcurrentHashMap\n();\n\n  private final FooStats stats;\n\n  public Foo(String id) {\n    stats = STATS.computeIfAbsent(id, (i) -\n new FooStats(i));\n  }\n\n  public void doSomething() {\n    ...\n    stats.update();\n  }\n}\n\n\n\n\nThis ensures that there is a single copy for a given id. In spectator this\nexample would look like: \n\n\npublic class Foo {\n\n  private AtomicInteger gauge;\n  private Counter counter;\n\n  public Foo(Registry registry, String id) {\n    Id gaugeId = registry.createId(\ngauge\n).withTag(\nid\n, id);\n    gauge = registry.gauge(gaugeId, new AtomicInteger());\n    counter = registry.counter(\ncounter\n, \nid\n, id);\n  }\n\n  public void doSomething() {\n    ...\n  }\n}\n\n\n\n\nEverything using the same registry will get the same counter\ninstance if the same id is used. For the gauge the registry will\nkeep a weak reference and will sum the values if multiple instances are\npresent. Since it is a weak reference, nothing will prevent an instance of\n\nFoo\n from getting garbage collected.\n\n\nAnnotations\n\n\nAnnotations are not supported, use the appropriate meter type:\n\n\n\n\n\n\n\n\nDataSourceType\n\n\nSpectator Alternative\n\n\n\n\n\n\n\n\n\n\nCOUNTER\n\n\n[[Counter Usage]]\n\n\n\n\n\n\nGAUGE\n\n\n[[Gauge Usage]]\n\n\n\n\n\n\nINFORMATIONAL\n\n\nNot supported\n\n\n\n\n\n\n\n\nBasicCounter\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ncounter usage\n.\n\n\nServo:\n\n\npublic class Foo {\n  private final Counter c =\n    new BasicCounter(MonitorConfig.builder(\nname\n).build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n\n  public void doSomething() {\n    c.increment();\n  }\n}\n\n\n\n\nSpectator:\n\n\npublic class Foo {\n  private final Counter c;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    c = registry.counter(\nname\n, \nid\n, id);\n  }\n\n  public void doSomething() {\n    c.increment();\n  }\n}\n\n\n\n\nBasicGauge\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ngauge usage\n.\n\n\nServo:\n\n\npublic class Foo {\n  private final BasicGauge g = new BasicGauge(\n    MonitorConfig.builder(\nname\n).build(),\n    this::getCurrentValue);\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n}\n\n\n\n\nSpectator:\n\n\npublic class Foo {\n  @Inject\n  public Foo(Registry registry, String id) {\n    Id gaugeId = registry.createId(\nname\n).withTag(\nid\n, id);\n    registry.gauge(gaugeId, this, Foo::getCurrentValue);\n  }\n}\n\n\n\n\nBasicTimer\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ntimer usage\n. Note in spectator the reported unit\nfor timers is always seconds and cannot be changed. Seconds is the base unit\nand other units should only be used as a presentation detail. Servo allows\nthe unit to be customized and defaults to milliseconds.\n\n\nServo:\n\n\npublic class Foo {\n  private final Timer t = new BasicTimer(\n    MonitorConfig.builder(\nname\n).build(), TimeUnit.SECONDS);\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n\n  public void doSomething() {\n    Stopwatch s = t.start();\n    try {\n      ...\n    } finally {\n      s.stop();\n    }\n  }\n}\n\n\n\n\nSpectator:\n\n\npublic class Foo {\n  private final Timer t;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    t = registry.timer(\nname\n, \nid\n, id);\n  }\n\n  public void doSomething() {\n    t.record(() -\n {\n      ...\n    });\n  }\n}\n\n\n\n\nBasicDistributionSummary\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ndistribution summary usage\n.\n\n\nServo:\n\n\npublic class Foo {\n  private final BasicDistributionSummary s = new BasicDistributionSummary(\n    MonitorConfig.builder(\nname\n).build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n\n  public void doSomething() {\n    ...\n    s.record(getValue());\n  }\n}\n\n\n\n\nSpectator:\n\n\npublic class Foo {\n  private final DistributionSummary s;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    s = registry.distributionSummary(\nname\n, \nid\n, id);\n  }\n\n  public void doSomething() {\n    ...\n    s.record(getValue());\n  }\n}\n\n\n\n\nBasicInformational\n\n\nNot supported, see \noverview of differences\n.\n\n\nBasicStopwatch\n\n\nThere isn't an explicit stopwatch class in spectator. Just use a timing\ncall directly. \n\n\nServo:\n\n\n  public void doSomething() {\n    Stopwatch s = timer.start();\n    try {\n      ...\n    } finally {\n      s.stop();\n    }\n  }\n\n\n\n\nSpectator:\n\n\n  public void doSomething() {\n    final long s = System.nanoTime();\n    try {\n      ...\n    } finally {\n      timer.record(System.nanoTime() - s, TimeUnit.NANOSECONDS);\n    }\n  }\n\n\n\n\nBucketTimer\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \nsandbox documentation\n. Note in spectator BucketTimer is\nprovided in the sandbox extension library and may change in future as we\ngain more experience using it.\n\n\nServo:\n\n\npublic class Foo {\n  private final Timer t = new BucketTimer(\n    MonitorConfig.builder(\nname\n).build(),\n    new BucketConfig.Builder()\n      .withTimeUnit(TimeUnit.MILLISECONDS)\n      .withBuckets(new long[] { 500, 2500, 5000, 10000 })\n      .build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n\n  public void doSomething() {\n    Stopwatch s = t.start();\n    try {\n      ...\n    } finally {\n      s.stop();\n    }\n  }\n}\n\n\n\n\nSpectator:\n\n\npublic class Foo {\n  private final Timer t;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    Id timerId = registry.createId(\nname\n, \nid\n, id);\n    BucketFunction f = BucketFunctions.latency(10, TimeUnit.SECONDS);\n    t = BucketTimer.get(registry, timerId, f);\n  }\n\n  public void doSomething() {\n    t.record(() -\n {\n      ...\n    });\n  }\n}\n\n\n\n\nContextualCounter\n\n\nNot supported. A fixed tag list for the context is too rigid and this class\nwas never used much at Netflix. Future work being looked at in\n\nissue-180\n.\n\n\nContextualTimer\n\n\nNot supported. A fixed tag list for the context is too rigid and this class\nwas never used much at Netflix. Future work being looked at in\n\nissue-180\n.\n\n\nDoubleGauge\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ngauge usage\n.\n\n\nServo:\n\n\npublic class Foo {\n  private final DoubleGauge g = new DoubleGauge(\n    MonitorConfig.builder(\nname\n).build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n}\n\n\n\n\nSpectator:\n\n\nimport com.google.common.util.concurrent.AtomicDouble;\n\npublic class Foo {\n  private final AtomicDouble v;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    Id gaugeId = registry.createId(\nname\n).withTag(\nid\n, id);\n    v = registry.gauge(gaugeId, new AtomicDouble());\n  }\n}\n\n\n\n\nDurationTimer\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ntimer usage\n.\n\n\nServo:\n\n\npublic class Foo {\n  private final DurationTimer t = new DurationTimer(\n    MonitorConfig.builder(\nname\n).build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n}\n\n\n\n\nSpectator:\n\n\npublic class Foo {\n  private final LongTaskTimer t;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    t = registry.longTaskTimer(\nname\n, \nid\n, id);\n  }\n}\n\n\n\n\nDynamicCounter\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ncounter usage\n.\n\n\nServo:\n\n\npublic class Foo {\n\n  private final String id;\n\n  public Foo(String id) {\n    this.id = id;\n  }\n\n  public void doSomething(Context ctxt) {\n    DynamicCounter.increment(\nstaticId\n, \nid\n, id);\n    DynamicCounter.increment(\ndynamicId\n, \nid\n, id, \nfoo\n, ctxt.getFoo());\n  }\n}\n\n\n\n\nSpectator:\n\n\npublic class Foo {\n  private final Registry registry;\n  private final String id;\n  private final Counter staticCounter;\n  private final Id dynamicId;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    this.registry = registry;\n    this.id = id;\n    staticCounter = registry.counter(\nstaticId\n, \nid\n, id);\n    dynamicId = registry.createId(\ndynamicId\n, \nid\n, id);\n  }\n\n  public void doSomething(Context ctxt) {\n    // Keeping the reference to the counter avoids additional allocations\n    // to create the id object and the lookup cost\n    staticCounter.increment();\n\n    // If the id is dynamic it must be looked up\n    registry.counter(\ndynamicId\n, \nid\n, id, \nfoo\n, ctxt.getFoo()).increment();\n\n    // This will update the same counter as the line above, but the base part\n    // of the id is precomputed to make it cheaper to construct the id.\n    registry.counter(dynamicId.withTag(\nfoo\n, ctxt.getFoo())).increment();\n  }\n}\n\n\n\n\nDynamicTimer\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ntimer usage\n.\n\n\nServo:\n\n\npublic class Foo {\n\n  private final String id;\n  private final MonitorConfig staticId;\n\n  public Foo(String id) {\n    this.id = id;\n    staticId = MonitorConfig.builder(\nstaticId\n).withTag(\nid\n, id).build();\n  }\n\n  public void doSomething(Context ctxt) {\n    final long d = ctxt.getDurationMillis();\n    DynamicTimer.record(staticId, TimeUnit.SECONDS, d, TimeUnit.MILLISECONDS);\n\n    MonitorConfig dynamicId = MonitorConfig.builder(\ndynamicId\n)\n      .withTag(\nid\n, id)\n      .withTag(\nfoo\n, ctxt.getFoo())\n      .build();\n    DynamicTimer.record(dynamicId, TimeUnit.SECONDS, d, TimeUnit.MILLISECONDS);\n  }\n}\n\n\n\n\nSpectator:\n\n\npublic class Foo {\n  private final Registry registry;\n  private final String id;\n  private final Timer staticTimer;\n  private final Id dynamicId;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    this.registry = registry;\n    this.id = id;\n    staticTimer = registry.timer(\nstaticId\n, \nid\n, id);\n    dynamicId = registry.createId(\ndynamicId\n, \nid\n, id);\n  }\n\n  public void doSomething(Context ctxt) {\n    final long d = ctxt.getDurationMillis();\n\n    // Keeping the reference to the timer avoids additional allocations\n    // to create the id object and the lookup cost\n    staticTimer.record(d, TimeUnit.MILLISECONDS);\n\n    // If the id is dynamic it must be looked up\n    registry.timer(\ndynamicId\n, \nid\n, id, \nfoo\n, ctxt.getFoo())\n      .record(d, TimeUnit.MILLISECONDS);\n\n    // This will update the same timer as the line above, but the base part\n    // of the id is precomputed to make it cheaper to construct the id.\n    registry.timer(dynamicId.withTag(\nfoo\n, ctxt.getFoo()))\n      .record(d, TimeUnit.MILLISECONDS);\n  }\n}\n\n\n\n\nLongGauge\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ngauge usage\n.\n\n\nServo:\n\n\npublic class Foo {\n  private final LongGauge g = new LongGauge(\n    MonitorConfig.builder(\nname\n).build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n}\n\n\n\n\nSpectator:\n\n\npublic class Foo {\n  private final AtomicLong v;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    Id gaugeId = registry.createId(\nname\n).withTag(\nid\n, id);\n    v = registry.gauge(gaugeId, new AtomicLong());\n  }\n}\n\n\n\n\nMonitorConfig\n\n\nSee the documentation on \nnaming\n.\n\n\nServo:\n\n\nMonitorConfig id = MonitorConfig.builder(\nname\n)\n  .withTag(\ncountry\n, \nUS\n)\n  .withTag(\ndevice\n,  \nxbox\n)\n  .build();\n\n\n\n\nSpectator:\n\n\nId id = registry.createId(\nname\n)\n  .withTag(\ncountry\n, \nUS\n)\n  .withTag(\ndevice\n,  \nxbox\n);\n\n// or\n\nId id = registry.createId(\nname\n, \ncountry\n, \nUS\n, \ndevice\n, \nxbox\n);\n\n\n\n\nMonitoredCache\n\n\nNot supported because spectator does not have a direct dependency on guava.\nIf there is enough demand an extension can be created.\n\n\nNumberGauge\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ngauge usage\n.\n\n\nServo:\n\n\npublic class Foo {\n  private final NumberGauge g = new NumberGauge(\n    MonitorConfig.builder(\nname\n).build(), new AtomicLong());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n}\n\n\n\n\nSpectator:\n\n\npublic class Foo {\n  private final AtomicLong v;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    Id gaugeId = registry.createId(\nname\n).withTag(\nid\n, id);\n    v = registry.gauge(gaugeId, new AtomicLong());\n  }\n}\n\n\n\n\nStatsTimer\n\n\nNot supported, see \noverview of differences\n.\n\n\nStepCounter\n\n\nSee the general overview of \nregistration differences\n and\nsummary of \ncounter usage\n.\n\n\nServo:\n\n\npublic class Foo {\n  private final Counter c =\n    new StepCounter(MonitorConfig.builder(\nname\n).build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n\n  public void doSomething() {\n    c.increment();\n  }\n}\n\n\n\n\nSpectator:\n\n\npublic class Foo {\n  private final Counter c;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    c = registry.counter(\nname\n, \nid\n, id);\n  }\n\n  public void doSomething() {\n    c.increment();\n  }\n}", 
            "title": "Servo Comparison"
        }, 
        {
            "location": "/intro/servo-comparison/#servo-comparison", 
            "text": "Servo  is an alternative client monitoring\nlibrary that is also developed by Netflix. Originally spectator was an\nexperiment for a simpler API that wrapped servo. It was done as a separate\nproject to avoid breaking backwards compatibility for servo.  From a user perspective, both will be supported for a long time, but most\nof our efforts for future improvement will go to spectator. For new code it\nis recommended to use the spectator API. If running at Netflix  the correct bindings will be in place\nfor both servo and spectator.", 
            "title": "Servo Comparison"
        }, 
        {
            "location": "/intro/servo-comparison/#differences", 
            "text": "This section provides a quick summary of the differences.", 
            "title": "Differences"
        }, 
        {
            "location": "/intro/servo-comparison/#simpler-api", 
            "text": "Servo gives the user a lot of control, but this makes it hard to use\ncorrectly. For example, to create a counter the user needs to understand\nthe tradeoffs and choose between:   BasicCounter  DynamicCounter  ContextualCounter  StepCounter   Further each of these can impact how data is reported to observers. The\nspectator API focuses on the constructs a user needs to instrument the\ncode. In spectator the user would always use the registry to create a Counter . The implementation details are left up to the\nregistry.  The  registration  is simpler as well to avoid common pitfalls\nwhen using servo like overwriting a registered object.", 
            "title": "Simpler API"
        }, 
        {
            "location": "/intro/servo-comparison/#more-focused", 
            "text": "The goal of spectator is instrumenting code to send to a dimensional\ntime-series system like  Atlas .\nServo has goals of staying compatible with a number of legacy libraries\nand naming formats, exposing data to JMX, etc. Examples of how this\ninfluences decisions:   No support for non-numeric data. Servo supported this for exposing to JMX.\n  Exposing the numeric data registered in spectator to JMX can be done\n  using a registry that supports it, but there is no goal to be a general\n  interface for exposing arbitrary data in JMX.  No support for customizeable time units when reporting timer data. Base\n  units should always be used for reporting and conversions can be performed\n  in the presentation layer if needed. It also avoids a lot of the confusion\n  around the timer unit for the data and issues like creating aggregates that\n  are meaningless because of mixed units.   It is better to have a simple way to get correct and easy to reason about\ndata to the backend than many options. If you want more knobs, then you can use\nServo.", 
            "title": "More Focused"
        }, 
        {
            "location": "/intro/servo-comparison/#di-friendly", 
            "text": "When servo was originally written dependency injection was not heavily used\nat Netflix. Further servo needed to stay compatible with a number of use-cases\nthat were heavily static.  While spectator does have a static registry that can be used, the recommended\nway is to create a registry and inject it either manually or via a framework\ninto the classes that need it. This also makes it much easier to test in isolation .", 
            "title": "DI Friendly"
        }, 
        {
            "location": "/intro/servo-comparison/#migration", 
            "text": "If you want to migrate from the servo API to the spectator API, then this\nsection provides some guides on how servo constructs can be ported over. The\nsub-sections are the class names of monitor types supported by servo.  For users at Netflix, note we are not actively pushing teams to migrate\nor do any additional work. Servo is still supported and if it works for your\nuse-cases feel free to continue using it.", 
            "title": "Migration"
        }, 
        {
            "location": "/intro/servo-comparison/#registration", 
            "text": "First read through the  servo docs on registration .\nIn servo if you have a class like:  public class Foo {\n\n  private AtomicInteger gauge;\n  private Counter counter;\n\n  public Foo(String id) {\n    gauge = new AtomicInteger();\n    counter = new BasicCounter(MonitorConfig.builder( counter ).build());\n    Monitors.registerObject(id, this);\n  }\n\n  @Monitor(name =  gauge , type = DataSourceType.GAUGE)\n  private int gauge() {\n    return gauge.get();\n  }\n\n  public void doSomething() {\n    ...\n  }\n}  The state of the class is in the member variables of an instance of  Foo .\nIf multiple instances of class  Foo  are created with the same value for  id ,\nthen the last one will overwrite the others for the registration. So the\nvalues getting reported will only be from the last instance registered. Also\nthe registry has a reference to the instance of  Foo  so it will never go\naway.  For counters and timers one way to get around this is to use DynamicCounter  and  DynamicTimer \nrespectively. Those classes will automatically handle the registration and\nexpire if there is no activity. They also get used for cases where the set\nof dimensions is not known up front.  Gauges need to sample the state of something so they need to have a reference\nto an object that contains the state. So the user would need to ensure that\nonly a single copy was registered leading to patterns like:  class Foo {\n\n  private static class FooStats {\n\n    private AtomicInteger gauge;\n    private Counter counter;\n\n    public FooStats(String id) {\n      gauge = new AtomicInteger();\n      counter = new BasicCounter(MonitorConfig.builder( counter ).build());\n      Monitors.registerObject(id, this);\n    }\n\n    @Monitor(name =  gauge , type = DataSourceType.GAUGE)\n    private int gauge() {\n      return gauge.get();\n    }\n  }\n\n  private static ConcurrentHashMap String, FooStats  STATS =\n    new ConcurrentHashMap ();\n\n  private final FooStats stats;\n\n  public Foo(String id) {\n    stats = STATS.computeIfAbsent(id, (i) -  new FooStats(i));\n  }\n\n  public void doSomething() {\n    ...\n    stats.update();\n  }\n}  This ensures that there is a single copy for a given id. In spectator this\nexample would look like:   public class Foo {\n\n  private AtomicInteger gauge;\n  private Counter counter;\n\n  public Foo(Registry registry, String id) {\n    Id gaugeId = registry.createId( gauge ).withTag( id , id);\n    gauge = registry.gauge(gaugeId, new AtomicInteger());\n    counter = registry.counter( counter ,  id , id);\n  }\n\n  public void doSomething() {\n    ...\n  }\n}  Everything using the same registry will get the same counter\ninstance if the same id is used. For the gauge the registry will\nkeep a weak reference and will sum the values if multiple instances are\npresent. Since it is a weak reference, nothing will prevent an instance of Foo  from getting garbage collected.", 
            "title": "Registration"
        }, 
        {
            "location": "/intro/servo-comparison/#annotations", 
            "text": "Annotations are not supported, use the appropriate meter type:     DataSourceType  Spectator Alternative      COUNTER  [[Counter Usage]]    GAUGE  [[Gauge Usage]]    INFORMATIONAL  Not supported", 
            "title": "Annotations"
        }, 
        {
            "location": "/intro/servo-comparison/#basiccounter", 
            "text": "See the general overview of  registration differences  and\nsummary of  counter usage .  Servo:  public class Foo {\n  private final Counter c =\n    new BasicCounter(MonitorConfig.builder( name ).build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n\n  public void doSomething() {\n    c.increment();\n  }\n}  Spectator:  public class Foo {\n  private final Counter c;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    c = registry.counter( name ,  id , id);\n  }\n\n  public void doSomething() {\n    c.increment();\n  }\n}", 
            "title": "BasicCounter"
        }, 
        {
            "location": "/intro/servo-comparison/#basicgauge", 
            "text": "See the general overview of  registration differences  and\nsummary of  gauge usage .  Servo:  public class Foo {\n  private final BasicGauge g = new BasicGauge(\n    MonitorConfig.builder( name ).build(),\n    this::getCurrentValue);\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n}  Spectator:  public class Foo {\n  @Inject\n  public Foo(Registry registry, String id) {\n    Id gaugeId = registry.createId( name ).withTag( id , id);\n    registry.gauge(gaugeId, this, Foo::getCurrentValue);\n  }\n}", 
            "title": "BasicGauge"
        }, 
        {
            "location": "/intro/servo-comparison/#basictimer", 
            "text": "See the general overview of  registration differences  and\nsummary of  timer usage . Note in spectator the reported unit\nfor timers is always seconds and cannot be changed. Seconds is the base unit\nand other units should only be used as a presentation detail. Servo allows\nthe unit to be customized and defaults to milliseconds.  Servo:  public class Foo {\n  private final Timer t = new BasicTimer(\n    MonitorConfig.builder( name ).build(), TimeUnit.SECONDS);\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n\n  public void doSomething() {\n    Stopwatch s = t.start();\n    try {\n      ...\n    } finally {\n      s.stop();\n    }\n  }\n}  Spectator:  public class Foo {\n  private final Timer t;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    t = registry.timer( name ,  id , id);\n  }\n\n  public void doSomething() {\n    t.record(() -  {\n      ...\n    });\n  }\n}", 
            "title": "BasicTimer"
        }, 
        {
            "location": "/intro/servo-comparison/#basicdistributionsummary", 
            "text": "See the general overview of  registration differences  and\nsummary of  distribution summary usage .  Servo:  public class Foo {\n  private final BasicDistributionSummary s = new BasicDistributionSummary(\n    MonitorConfig.builder( name ).build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n\n  public void doSomething() {\n    ...\n    s.record(getValue());\n  }\n}  Spectator:  public class Foo {\n  private final DistributionSummary s;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    s = registry.distributionSummary( name ,  id , id);\n  }\n\n  public void doSomething() {\n    ...\n    s.record(getValue());\n  }\n}", 
            "title": "BasicDistributionSummary"
        }, 
        {
            "location": "/intro/servo-comparison/#basicinformational", 
            "text": "Not supported, see  overview of differences .", 
            "title": "BasicInformational"
        }, 
        {
            "location": "/intro/servo-comparison/#basicstopwatch", 
            "text": "There isn't an explicit stopwatch class in spectator. Just use a timing\ncall directly.   Servo:    public void doSomething() {\n    Stopwatch s = timer.start();\n    try {\n      ...\n    } finally {\n      s.stop();\n    }\n  }  Spectator:    public void doSomething() {\n    final long s = System.nanoTime();\n    try {\n      ...\n    } finally {\n      timer.record(System.nanoTime() - s, TimeUnit.NANOSECONDS);\n    }\n  }", 
            "title": "BasicStopwatch"
        }, 
        {
            "location": "/intro/servo-comparison/#buckettimer", 
            "text": "See the general overview of  registration differences  and\nsummary of  sandbox documentation . Note in spectator BucketTimer is\nprovided in the sandbox extension library and may change in future as we\ngain more experience using it.  Servo:  public class Foo {\n  private final Timer t = new BucketTimer(\n    MonitorConfig.builder( name ).build(),\n    new BucketConfig.Builder()\n      .withTimeUnit(TimeUnit.MILLISECONDS)\n      .withBuckets(new long[] { 500, 2500, 5000, 10000 })\n      .build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n\n  public void doSomething() {\n    Stopwatch s = t.start();\n    try {\n      ...\n    } finally {\n      s.stop();\n    }\n  }\n}  Spectator:  public class Foo {\n  private final Timer t;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    Id timerId = registry.createId( name ,  id , id);\n    BucketFunction f = BucketFunctions.latency(10, TimeUnit.SECONDS);\n    t = BucketTimer.get(registry, timerId, f);\n  }\n\n  public void doSomething() {\n    t.record(() -  {\n      ...\n    });\n  }\n}", 
            "title": "BucketTimer"
        }, 
        {
            "location": "/intro/servo-comparison/#contextualcounter", 
            "text": "Not supported. A fixed tag list for the context is too rigid and this class\nwas never used much at Netflix. Future work being looked at in issue-180 .", 
            "title": "ContextualCounter"
        }, 
        {
            "location": "/intro/servo-comparison/#contextualtimer", 
            "text": "Not supported. A fixed tag list for the context is too rigid and this class\nwas never used much at Netflix. Future work being looked at in issue-180 .", 
            "title": "ContextualTimer"
        }, 
        {
            "location": "/intro/servo-comparison/#doublegauge", 
            "text": "See the general overview of  registration differences  and\nsummary of  gauge usage .  Servo:  public class Foo {\n  private final DoubleGauge g = new DoubleGauge(\n    MonitorConfig.builder( name ).build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n}  Spectator:  import com.google.common.util.concurrent.AtomicDouble;\n\npublic class Foo {\n  private final AtomicDouble v;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    Id gaugeId = registry.createId( name ).withTag( id , id);\n    v = registry.gauge(gaugeId, new AtomicDouble());\n  }\n}", 
            "title": "DoubleGauge"
        }, 
        {
            "location": "/intro/servo-comparison/#durationtimer", 
            "text": "See the general overview of  registration differences  and\nsummary of  timer usage .  Servo:  public class Foo {\n  private final DurationTimer t = new DurationTimer(\n    MonitorConfig.builder( name ).build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n}  Spectator:  public class Foo {\n  private final LongTaskTimer t;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    t = registry.longTaskTimer( name ,  id , id);\n  }\n}", 
            "title": "DurationTimer"
        }, 
        {
            "location": "/intro/servo-comparison/#dynamiccounter", 
            "text": "See the general overview of  registration differences  and\nsummary of  counter usage .  Servo:  public class Foo {\n\n  private final String id;\n\n  public Foo(String id) {\n    this.id = id;\n  }\n\n  public void doSomething(Context ctxt) {\n    DynamicCounter.increment( staticId ,  id , id);\n    DynamicCounter.increment( dynamicId ,  id , id,  foo , ctxt.getFoo());\n  }\n}  Spectator:  public class Foo {\n  private final Registry registry;\n  private final String id;\n  private final Counter staticCounter;\n  private final Id dynamicId;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    this.registry = registry;\n    this.id = id;\n    staticCounter = registry.counter( staticId ,  id , id);\n    dynamicId = registry.createId( dynamicId ,  id , id);\n  }\n\n  public void doSomething(Context ctxt) {\n    // Keeping the reference to the counter avoids additional allocations\n    // to create the id object and the lookup cost\n    staticCounter.increment();\n\n    // If the id is dynamic it must be looked up\n    registry.counter( dynamicId ,  id , id,  foo , ctxt.getFoo()).increment();\n\n    // This will update the same counter as the line above, but the base part\n    // of the id is precomputed to make it cheaper to construct the id.\n    registry.counter(dynamicId.withTag( foo , ctxt.getFoo())).increment();\n  }\n}", 
            "title": "DynamicCounter"
        }, 
        {
            "location": "/intro/servo-comparison/#dynamictimer", 
            "text": "See the general overview of  registration differences  and\nsummary of  timer usage .  Servo:  public class Foo {\n\n  private final String id;\n  private final MonitorConfig staticId;\n\n  public Foo(String id) {\n    this.id = id;\n    staticId = MonitorConfig.builder( staticId ).withTag( id , id).build();\n  }\n\n  public void doSomething(Context ctxt) {\n    final long d = ctxt.getDurationMillis();\n    DynamicTimer.record(staticId, TimeUnit.SECONDS, d, TimeUnit.MILLISECONDS);\n\n    MonitorConfig dynamicId = MonitorConfig.builder( dynamicId )\n      .withTag( id , id)\n      .withTag( foo , ctxt.getFoo())\n      .build();\n    DynamicTimer.record(dynamicId, TimeUnit.SECONDS, d, TimeUnit.MILLISECONDS);\n  }\n}  Spectator:  public class Foo {\n  private final Registry registry;\n  private final String id;\n  private final Timer staticTimer;\n  private final Id dynamicId;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    this.registry = registry;\n    this.id = id;\n    staticTimer = registry.timer( staticId ,  id , id);\n    dynamicId = registry.createId( dynamicId ,  id , id);\n  }\n\n  public void doSomething(Context ctxt) {\n    final long d = ctxt.getDurationMillis();\n\n    // Keeping the reference to the timer avoids additional allocations\n    // to create the id object and the lookup cost\n    staticTimer.record(d, TimeUnit.MILLISECONDS);\n\n    // If the id is dynamic it must be looked up\n    registry.timer( dynamicId ,  id , id,  foo , ctxt.getFoo())\n      .record(d, TimeUnit.MILLISECONDS);\n\n    // This will update the same timer as the line above, but the base part\n    // of the id is precomputed to make it cheaper to construct the id.\n    registry.timer(dynamicId.withTag( foo , ctxt.getFoo()))\n      .record(d, TimeUnit.MILLISECONDS);\n  }\n}", 
            "title": "DynamicTimer"
        }, 
        {
            "location": "/intro/servo-comparison/#longgauge", 
            "text": "See the general overview of  registration differences  and\nsummary of  gauge usage .  Servo:  public class Foo {\n  private final LongGauge g = new LongGauge(\n    MonitorConfig.builder( name ).build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n}  Spectator:  public class Foo {\n  private final AtomicLong v;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    Id gaugeId = registry.createId( name ).withTag( id , id);\n    v = registry.gauge(gaugeId, new AtomicLong());\n  }\n}", 
            "title": "LongGauge"
        }, 
        {
            "location": "/intro/servo-comparison/#monitorconfig", 
            "text": "See the documentation on  naming .  Servo:  MonitorConfig id = MonitorConfig.builder( name )\n  .withTag( country ,  US )\n  .withTag( device ,   xbox )\n  .build();  Spectator:  Id id = registry.createId( name )\n  .withTag( country ,  US )\n  .withTag( device ,   xbox );\n\n// or\n\nId id = registry.createId( name ,  country ,  US ,  device ,  xbox );", 
            "title": "MonitorConfig"
        }, 
        {
            "location": "/intro/servo-comparison/#monitoredcache", 
            "text": "Not supported because spectator does not have a direct dependency on guava.\nIf there is enough demand an extension can be created.", 
            "title": "MonitoredCache"
        }, 
        {
            "location": "/intro/servo-comparison/#numbergauge", 
            "text": "See the general overview of  registration differences  and\nsummary of  gauge usage .  Servo:  public class Foo {\n  private final NumberGauge g = new NumberGauge(\n    MonitorConfig.builder( name ).build(), new AtomicLong());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n}  Spectator:  public class Foo {\n  private final AtomicLong v;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    Id gaugeId = registry.createId( name ).withTag( id , id);\n    v = registry.gauge(gaugeId, new AtomicLong());\n  }\n}", 
            "title": "NumberGauge"
        }, 
        {
            "location": "/intro/servo-comparison/#statstimer", 
            "text": "Not supported, see  overview of differences .", 
            "title": "StatsTimer"
        }, 
        {
            "location": "/intro/servo-comparison/#stepcounter", 
            "text": "See the general overview of  registration differences  and\nsummary of  counter usage .  Servo:  public class Foo {\n  private final Counter c =\n    new StepCounter(MonitorConfig.builder( name ).build());\n\n  public Foo(String id) {\n    Monitors.registerObject(id, this);\n  }\n\n  public void doSomething() {\n    c.increment();\n  }\n}  Spectator:  public class Foo {\n  private final Counter c;\n\n  @Inject\n  public Foo(Registry registry, String id) {\n    c = registry.counter( name ,  id , id);\n  }\n\n  public void doSomething() {\n    c.increment();\n  }\n}", 
            "title": "StepCounter"
        }, 
        {
            "location": "/ext/jvm-buffer-pools/", 
            "text": "Buffer Pools\n\n\nBuffer pools, such as direct byte buffers, can be monitored at a high level using the\n\nBufferPoolMXBean\n\nprovided by the JDK. \n\n\nGetting Started\n\n\nTo get information about buffer pools in spectator just setup registration of standard MXBeans.\nNote, if you are building an app at Netflix this should happen automatically via the normal\nplatform initialization.\n\n\nimport com.netflix.spectator.api.Spectator;\nimport com.netflix.spectator.jvm.Jmx;\n\nJmx.registerStandardMXBeans(Spectator.registry());\n\n\n\n\nMetrics\n\n\njvm.buffer.count\n\n\nGauge showing the current number of distinct buffers.\n\n\nUnit:\n count \n\n\nDimensions:\n\n\n\n\nid\n: type of buffers. Value will be either \ndirect\n for direct byte buffers or \nmapped\n for\n  memory mapped files.\n\n\n\n\njvm.buffer.memoryUsed\n\n\nGauge showing the current number of bytes used by all buffers.\n\n\nUnit:\n bytes \n\n\nDimensions:\n\n\n\n\nid\n: type of buffers. Value will be either \ndirect\n for direct byte buffers or \nmapped\n for\n  memory mapped files.", 
            "title": "Buffer Pools"
        }, 
        {
            "location": "/ext/jvm-buffer-pools/#buffer-pools", 
            "text": "Buffer pools, such as direct byte buffers, can be monitored at a high level using the BufferPoolMXBean \nprovided by the JDK.", 
            "title": "Buffer Pools"
        }, 
        {
            "location": "/ext/jvm-buffer-pools/#getting-started", 
            "text": "To get information about buffer pools in spectator just setup registration of standard MXBeans.\nNote, if you are building an app at Netflix this should happen automatically via the normal\nplatform initialization.  import com.netflix.spectator.api.Spectator;\nimport com.netflix.spectator.jvm.Jmx;\n\nJmx.registerStandardMXBeans(Spectator.registry());", 
            "title": "Getting Started"
        }, 
        {
            "location": "/ext/jvm-buffer-pools/#metrics", 
            "text": "", 
            "title": "Metrics"
        }, 
        {
            "location": "/ext/jvm-buffer-pools/#jvmbuffercount", 
            "text": "Gauge showing the current number of distinct buffers.  Unit:  count   Dimensions:   id : type of buffers. Value will be either  direct  for direct byte buffers or  mapped  for\n  memory mapped files.", 
            "title": "jvm.buffer.count"
        }, 
        {
            "location": "/ext/jvm-buffer-pools/#jvmbuffermemoryused", 
            "text": "Gauge showing the current number of bytes used by all buffers.  Unit:  bytes   Dimensions:   id : type of buffers. Value will be either  direct  for direct byte buffers or  mapped  for\n  memory mapped files.", 
            "title": "jvm.buffer.memoryUsed"
        }, 
        {
            "location": "/ext/jvm-gc/", 
            "text": "Garbage Collection\n\n\nThe GC module registers with the notification emitter of the\n\nGarbageCollectorMXBean\n\nto provide some basic GC logging and metrics.\n\n\n\n\nGetting started\n\n\nLogging\n\n\nMetrics\n\n\nAlerting\n\n\n\n\nGetting Started\n\n\nFor using it internally at Netflix see the \nNetflix integration\n guide,\notherwise keep reading this section.\n\n\nRequirements\n\n\nThis library relies on the notification emitter added in 7u4, but there are known issues prior\nto 7u40. For G1 it is recommended to be on the latest version available.\n\n\nDependencies\n\n\ncom.netflix.spectator:spectator-ext-gc:0.38.0\n\n\n\n\nStart Reporting\n\n\nThen in the initialization for the application:\n\n\nimport com.netflix.spectator.gc.GcLogger;\n...\n// Keep a single instance of the logger\nGcLogger gc = new GcLogger();\ngc.start(null);\n\n\n\n\nLogging\n\n\nAfter GC events an INFO level log message will get reported using slf4j. This makes it easy to\nGC events in the context of other log messages for the application. The logger name is\n\ncom.netflix.spectator.gc.GcLogger\n and the message will look like:\n\n\n${GC_TYPE}: ${COLLECTOR_NAME}, id=${N}, at=${START_TIME}, duration=${T}ms, cause=[${CAUSE}], ${TOTAL_USAGE_BEFORE} =\n ${TOTAL_USAGE_AFTER} / ${MAX_SIZE} (${PERCENT_USAGE_BEFORE} =\n ${PERCENT_USAGE_AFTER})\n\n\n\n\nThe id can be used to verify events were not skipped or correlate with other sources like\ndetailed GC logs. See [[GC causes]] for more details on the possible causes.\n\n\nSample:\n\n\n2014-08-31 02:02:24,724  INFO [com.netflix.spectator.gc.GcLogger] YOUNG: ParNew, id=5281, at=Sun Aug 31 02:02:24 UTC 2014, duration=2ms, cause=[Allocation Failure], 0.4G =\n 0.3G / 1.8G (24.3% =\n 16.6%)\n\n\n\n\nMetrics\n\n\njvm.gc.allocationRate\n\n\nThe allocation rate measures how fast the application is allocating memory. It is a counter\nthat is incremented after a GC event by the amount \nyoungGen.sizeBeforeGC\n. Technically, right\nnow it is:\n\n\nyoungGen.sizeBeforeGC - youngGen.sizeAfterGC\n\n\nHowever, \nyoungGen.sizeAfterGC\n should be 0 and thus the size of young gen before the GC is\nthe amount allocated since the previous GC event.\n\n\nUnit:\n bytes/second\n\n\nDimensions:\n n/a\n\n\njvm.gc.promotionRate\n\n\nThe promotion rate measures how fast data is being moved from young generation into the old\ngeneration. It is a counter that is incremented after a GC event by the amount:\n\n\nabs(oldGen.sizeAfterGC - oldGen.sizeBeforeGC)\n\n\nUnit:\n bytes/second\n\n\nDimensions:\n n/a\n\n\njvm.gc.liveDataSize\n\n\nThe live data size is the size of the old generation after a major GC. The image below shows\nhow the live data size view compares to a metric showing the current size of the memory pool:\n\n\n\n\nUnit:\n bytes\n\n\nDimensions:\n n/a\n\n\njvm.gc.maxDataSize\n\n\nMaximum size for the old generation. Primary use-case is for gaining perspective on the the\nlive data size.\n\n\nUnit:\n bytes\n\n\nDimensions:\n n/a\n\n\njvm.gc.pause\n\n\nTimer reporting the pause time for a GC event. All of the values reported are stop the world\npauses.\n\n\nUnit:\n\n\n\n\nstatistic=max\n: seconds\n\n\nstatistic=count\n: events/second\n\n\nstatistic=totalTime\n: seconds/second \n\n\n\n\nDimensions:\n\n\n\n\naction\n: action performed by the garbage collector (\njavadoc\n). There is no guarantee, but the typical values seen are \nend_of_major_GC\n and \nend_of_minor_GC\n. \n\n\ncause\n: cause that instigated GC (\njavadoc\n). For an explanation of common causes see the [[GC Causes]] page.\n\n\n\n\nAlerting\n\n\nThis section assumes the data is available in \nAtlas\n,\nbut users of other systems should be able to take the idea and make it work. For all of these\nalerts it is recommended to check them on instance. At Netflix that can be done by selecting\nthe option in alert ui:\n\n\n\n\n\n\n\n\nMax Pause Time\n\n\nExample to trigger an alert if the \npause time\n exceeds 500 milliseconds:\n\n\nname,jvm.gc.pause,:eq,\nstatistic,max,:eq,\n:and,\n:max,(,cause,),:by,\n0.5,:gt,\n$cause,:legend\n\n\n\n\nHeap Pressure\n\n\nExample to trigger an alert if the \nlive data size\n is over 70% of the heap:\n\n\nname,jvm.gc.liveDataSize,:eq,:max,\nname,jvm.gc.maxDataSize,:eq,:max,\n:div,100,:mul,\n70,:gt,\npercentUsed,:legend", 
            "title": "Garbage Collection"
        }, 
        {
            "location": "/ext/jvm-gc/#garbage-collection", 
            "text": "The GC module registers with the notification emitter of the GarbageCollectorMXBean \nto provide some basic GC logging and metrics.   Getting started  Logging  Metrics  Alerting", 
            "title": "Garbage Collection"
        }, 
        {
            "location": "/ext/jvm-gc/#getting-started", 
            "text": "For using it internally at Netflix see the  Netflix integration  guide,\notherwise keep reading this section.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/ext/jvm-gc/#requirements", 
            "text": "This library relies on the notification emitter added in 7u4, but there are known issues prior\nto 7u40. For G1 it is recommended to be on the latest version available.", 
            "title": "Requirements"
        }, 
        {
            "location": "/ext/jvm-gc/#dependencies", 
            "text": "com.netflix.spectator:spectator-ext-gc:0.38.0", 
            "title": "Dependencies"
        }, 
        {
            "location": "/ext/jvm-gc/#start-reporting", 
            "text": "Then in the initialization for the application:  import com.netflix.spectator.gc.GcLogger;\n...\n// Keep a single instance of the logger\nGcLogger gc = new GcLogger();\ngc.start(null);", 
            "title": "Start Reporting"
        }, 
        {
            "location": "/ext/jvm-gc/#logging", 
            "text": "After GC events an INFO level log message will get reported using slf4j. This makes it easy to\nGC events in the context of other log messages for the application. The logger name is com.netflix.spectator.gc.GcLogger  and the message will look like:  ${GC_TYPE}: ${COLLECTOR_NAME}, id=${N}, at=${START_TIME}, duration=${T}ms, cause=[${CAUSE}], ${TOTAL_USAGE_BEFORE} =  ${TOTAL_USAGE_AFTER} / ${MAX_SIZE} (${PERCENT_USAGE_BEFORE} =  ${PERCENT_USAGE_AFTER})  The id can be used to verify events were not skipped or correlate with other sources like\ndetailed GC logs. See [[GC causes]] for more details on the possible causes.  Sample:  2014-08-31 02:02:24,724  INFO [com.netflix.spectator.gc.GcLogger] YOUNG: ParNew, id=5281, at=Sun Aug 31 02:02:24 UTC 2014, duration=2ms, cause=[Allocation Failure], 0.4G =  0.3G / 1.8G (24.3% =  16.6%)", 
            "title": "Logging"
        }, 
        {
            "location": "/ext/jvm-gc/#metrics", 
            "text": "", 
            "title": "Metrics"
        }, 
        {
            "location": "/ext/jvm-gc/#jvmgcallocationrate", 
            "text": "The allocation rate measures how fast the application is allocating memory. It is a counter\nthat is incremented after a GC event by the amount  youngGen.sizeBeforeGC . Technically, right\nnow it is:  youngGen.sizeBeforeGC - youngGen.sizeAfterGC  However,  youngGen.sizeAfterGC  should be 0 and thus the size of young gen before the GC is\nthe amount allocated since the previous GC event.  Unit:  bytes/second  Dimensions:  n/a", 
            "title": "jvm.gc.allocationRate"
        }, 
        {
            "location": "/ext/jvm-gc/#jvmgcpromotionrate", 
            "text": "The promotion rate measures how fast data is being moved from young generation into the old\ngeneration. It is a counter that is incremented after a GC event by the amount:  abs(oldGen.sizeAfterGC - oldGen.sizeBeforeGC)  Unit:  bytes/second  Dimensions:  n/a", 
            "title": "jvm.gc.promotionRate"
        }, 
        {
            "location": "/ext/jvm-gc/#jvmgclivedatasize", 
            "text": "The live data size is the size of the old generation after a major GC. The image below shows\nhow the live data size view compares to a metric showing the current size of the memory pool:   Unit:  bytes  Dimensions:  n/a", 
            "title": "jvm.gc.liveDataSize"
        }, 
        {
            "location": "/ext/jvm-gc/#jvmgcmaxdatasize", 
            "text": "Maximum size for the old generation. Primary use-case is for gaining perspective on the the\nlive data size.  Unit:  bytes  Dimensions:  n/a", 
            "title": "jvm.gc.maxDataSize"
        }, 
        {
            "location": "/ext/jvm-gc/#jvmgcpause", 
            "text": "Timer reporting the pause time for a GC event. All of the values reported are stop the world\npauses.  Unit:   statistic=max : seconds  statistic=count : events/second  statistic=totalTime : seconds/second    Dimensions:   action : action performed by the garbage collector ( javadoc ). There is no guarantee, but the typical values seen are  end_of_major_GC  and  end_of_minor_GC .   cause : cause that instigated GC ( javadoc ). For an explanation of common causes see the [[GC Causes]] page.", 
            "title": "jvm.gc.pause"
        }, 
        {
            "location": "/ext/jvm-gc/#alerting", 
            "text": "This section assumes the data is available in  Atlas ,\nbut users of other systems should be able to take the idea and make it work. For all of these\nalerts it is recommended to check them on instance. At Netflix that can be done by selecting\nthe option in alert ui:", 
            "title": "Alerting"
        }, 
        {
            "location": "/ext/jvm-gc/#max-pause-time", 
            "text": "Example to trigger an alert if the  pause time  exceeds 500 milliseconds:  name,jvm.gc.pause,:eq,\nstatistic,max,:eq,\n:and,\n:max,(,cause,),:by,\n0.5,:gt,\n$cause,:legend", 
            "title": "Max Pause Time"
        }, 
        {
            "location": "/ext/jvm-gc/#heap-pressure", 
            "text": "Example to trigger an alert if the  live data size  is over 70% of the heap:  name,jvm.gc.liveDataSize,:eq,:max,\nname,jvm.gc.maxDataSize,:eq,:max,\n:div,100,:mul,\n70,:gt,\npercentUsed,:legend", 
            "title": "Heap Pressure"
        }, 
        {
            "location": "/ext/jvm-gc-causes/", 
            "text": "GC Causes\n\n\nThe various GC causes aren't well documented. The list provided here comes from the\n\ngcCause.cpp\n\nfile in the jdk and we include some information on what these mean for the application.\n\n\nSystem.gc__\n\n\nSomething called \nSystem.gc()\n.\nIf you are seeing this once an hour it is likely related to the RMI GC interval. For more\ndetails see:\n\n\n\n\nUnexplained System.gc() calls due to Remote Method Invocation (RMI) or explict garbage collections\n\n\nsun.rmi.dgc.client.gcInterval\n\n\n\n\nFullGCAlot\n\n\nMost likely you'll never see this value. In debug builds of the jdk there is an option,\n\n-XX:+FullGCALot\n, that will trigger a full GC at a regular interval for testing purposes.\n\n\nScavengeAlot\n\n\nMost likely you'll never see this value. In debug builds of the jdk there is an option,\n\n-XX:+ScavengeALot\n, that will trigger a minor GC at a regular interval for testing purposes.\n\n\nAllocation_Profiler\n\n\nPrior to java 8 you would see this if running with the \n-Xaprof\n setting. It would be triggered\njust before the jvm exits. The \n-Xaprof\n option was removed in java 8.\n\n\nJvmtiEnv_ForceGarbageCollection\n\n\nSomething called the JVM tool interface function\n\nForceGarbageCollection\n.\nLook at the \n-agentlib\n param to java to see what agents are configured.\n\n\nGCLocker_Initiated_GC\n\n\nThe GC locker prevents GC from occurring when JNI code is in a\n\ncritical region\n.\nIf GC is needed while a thread is in a critical region, then it will allow them to complete,\ni.e. call the corresponding release function. Other threads will not be permitted to enter a\ncritical region. Once all threads are out of critical regions a GC event will be triggered. \n\n\nHeap_Inspection_Initiated_GC\n\n\nGC was initiated by an inspection operation on the heap. For example you can trigger this\nwith \njmap\n:\n\n\n$ jmap -histo:live \npid\n\n\nHeap_Dump_Initiated_GC\n\n\nGC was initiated before dumping the heap. For example you can trigger this with\n\njmap\n:\n\n\n$ jmap -dump:live,format=b,file=heap.out \npid\n\n\nAnother common example would be clicking the Heap Dump button on the Monitor tab in\n\njvisualvm\n.\n\n\nWhiteBox_Initiated_Young_GC\n\n\nMost likely you'll never see this value. Used for testing hotspot, it indicates something\ncalled \nsun.hotspot.WhiteBox.youngGC()\n. \n\n\nNo_GC\n\n\nUsed for CMS. Unfortunately when using the mbeans this is the cause that typically gets\nreported for a major GC.\n\n\nAllocation_Failure\n\n\nUsually this means that there is an allocation request that is bigger than the available space\nin young generation and will typically be associated with a minor GC. For G1 this will likely\nbe a major GC and it is more common to see \nG1_Evacuation_Pause\n for\nroutine minor collections.\n\n\nOn linux the jvm will trigger a GC if the kernel indicates there isn't much memory left via\n\nmem_notify\n.\n\n\nTenured_Generation_Full\n\n\nNot used?\n\n\nPermanent_Generation_Full\n\n\nTriggered as a result of an allocation failure in\n\nPermGen\n. Pre java 8.\n\n\nMetadata_GC_Threshold\n\n\nTriggered as a result of an allocation failure in\n\nMetaspace\n.\nMetaspace replaced PermGen was added in java 8.\n\n\nCMS_Generation_Full\n\n\nNot used?\n\n\nCMS_Initial_Mark\n\n\nInitial mark phase of CMS, for more details see\n\nPhases of CMS\n.\nUnfortunately it doesn't appear to be reported via the mbeans and we just get \nNo_GC\n.\n\n\nCMS_Final_Remark\n\n\nRemark phase of CMS, for more details see\n\nPhases of CMS\n.\nUnfortunately it doesn't appear to be reported via the mbeans and we just get \nNo_GC\n.\n\n\nCMS_Concurrent_Mark\n\n\nConcurrent mark phase of CMS, for more details see\n\nPhases of CMS\n.\nUnfortunately it doesn't appear to be reported via the mbeans and we just get \nNo_GC\n.\n\n\nOld_Generation_Expanded_On_Last_Scavenge\n\n\nNot used?\n\n\nOld_Generation_Too_Full_To_Scavenge\n\n\nNot used?\n\n\nErgonomics\n\n\nThis indicates you are using the adaptive size policy, \n-XX:+UseAdaptiveSizePolicy\n and is\non by default for recent versions, with the parallel collector (\n-XX:+UseParallelGC\n). For\nmore details see \nThe Why of GC Ergonomics\n.\n\n\nG1_Evacuation_Pause\n\n\nAn evacuation pause is the most common young gen cause for G1 and indicates that it is copying\nlive objects from one set of regions, young and sometimes young + old, to another set of\nregions. For more details see \nUnderstanding G1 GC Logs\n.\n\n\nG1_Humongous_Allocation\n\n\nA humongous allocation is one where the size is greater than 50% of the G1 region size. Before\na humongous allocation the jvm checks if it should do a routine\n\nevacuation pause\n without regard to the actual allocation size, but if\ntriggered due to this check the cause will be listed as humongous allocation. This cause is\nalso used for any collections used to free up enough space for the allocation. \n\n\nLast_ditch_collection\n\n\nFor perm gen (java 7 or earlier) and metaspace (java 8+) a last ditch collection will be\ntriggered if an allocation fails and the memory pool cannot be expanded.\n\n\nILLEGAL_VALUE_-\nlast_gc_cause\n-_ILLEGAL_VALUE\n\n\nIncluded for completeness, but you should never see this value.\n\n\nunknown_GCCause\n\n\nIncluded for completeness, but you should never see this value.", 
            "title": "GC Causes"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#gc-causes", 
            "text": "The various GC causes aren't well documented. The list provided here comes from the gcCause.cpp \nfile in the jdk and we include some information on what these mean for the application.", 
            "title": "GC Causes"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#systemgc__", 
            "text": "Something called  System.gc() .\nIf you are seeing this once an hour it is likely related to the RMI GC interval. For more\ndetails see:   Unexplained System.gc() calls due to Remote Method Invocation (RMI) or explict garbage collections  sun.rmi.dgc.client.gcInterval", 
            "title": "System.gc__"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#fullgcalot", 
            "text": "Most likely you'll never see this value. In debug builds of the jdk there is an option, -XX:+FullGCALot , that will trigger a full GC at a regular interval for testing purposes.", 
            "title": "FullGCAlot"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#scavengealot", 
            "text": "Most likely you'll never see this value. In debug builds of the jdk there is an option, -XX:+ScavengeALot , that will trigger a minor GC at a regular interval for testing purposes.", 
            "title": "ScavengeAlot"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#allocation_profiler", 
            "text": "Prior to java 8 you would see this if running with the  -Xaprof  setting. It would be triggered\njust before the jvm exits. The  -Xaprof  option was removed in java 8.", 
            "title": "Allocation_Profiler"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#jvmtienv_forcegarbagecollection", 
            "text": "Something called the JVM tool interface function ForceGarbageCollection .\nLook at the  -agentlib  param to java to see what agents are configured.", 
            "title": "JvmtiEnv_ForceGarbageCollection"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#gclocker_initiated_gc", 
            "text": "The GC locker prevents GC from occurring when JNI code is in a critical region .\nIf GC is needed while a thread is in a critical region, then it will allow them to complete,\ni.e. call the corresponding release function. Other threads will not be permitted to enter a\ncritical region. Once all threads are out of critical regions a GC event will be triggered.", 
            "title": "GCLocker_Initiated_GC"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#heap_inspection_initiated_gc", 
            "text": "GC was initiated by an inspection operation on the heap. For example you can trigger this\nwith  jmap :  $ jmap -histo:live  pid", 
            "title": "Heap_Inspection_Initiated_GC"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#heap_dump_initiated_gc", 
            "text": "GC was initiated before dumping the heap. For example you can trigger this with jmap :  $ jmap -dump:live,format=b,file=heap.out  pid  Another common example would be clicking the Heap Dump button on the Monitor tab in jvisualvm .", 
            "title": "Heap_Dump_Initiated_GC"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#whitebox_initiated_young_gc", 
            "text": "Most likely you'll never see this value. Used for testing hotspot, it indicates something\ncalled  sun.hotspot.WhiteBox.youngGC() .", 
            "title": "WhiteBox_Initiated_Young_GC"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#no_gc", 
            "text": "Used for CMS. Unfortunately when using the mbeans this is the cause that typically gets\nreported for a major GC.", 
            "title": "No_GC"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#allocation_failure", 
            "text": "Usually this means that there is an allocation request that is bigger than the available space\nin young generation and will typically be associated with a minor GC. For G1 this will likely\nbe a major GC and it is more common to see  G1_Evacuation_Pause  for\nroutine minor collections.  On linux the jvm will trigger a GC if the kernel indicates there isn't much memory left via mem_notify .", 
            "title": "Allocation_Failure"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#tenured_generation_full", 
            "text": "Not used?", 
            "title": "Tenured_Generation_Full"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#permanent_generation_full", 
            "text": "Triggered as a result of an allocation failure in PermGen . Pre java 8.", 
            "title": "Permanent_Generation_Full"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#metadata_gc_threshold", 
            "text": "Triggered as a result of an allocation failure in Metaspace .\nMetaspace replaced PermGen was added in java 8.", 
            "title": "Metadata_GC_Threshold"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#cms_generation_full", 
            "text": "Not used?", 
            "title": "CMS_Generation_Full"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#cms_initial_mark", 
            "text": "Initial mark phase of CMS, for more details see Phases of CMS .\nUnfortunately it doesn't appear to be reported via the mbeans and we just get  No_GC .", 
            "title": "CMS_Initial_Mark"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#cms_final_remark", 
            "text": "Remark phase of CMS, for more details see Phases of CMS .\nUnfortunately it doesn't appear to be reported via the mbeans and we just get  No_GC .", 
            "title": "CMS_Final_Remark"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#cms_concurrent_mark", 
            "text": "Concurrent mark phase of CMS, for more details see Phases of CMS .\nUnfortunately it doesn't appear to be reported via the mbeans and we just get  No_GC .", 
            "title": "CMS_Concurrent_Mark"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#old_generation_expanded_on_last_scavenge", 
            "text": "Not used?", 
            "title": "Old_Generation_Expanded_On_Last_Scavenge"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#old_generation_too_full_to_scavenge", 
            "text": "Not used?", 
            "title": "Old_Generation_Too_Full_To_Scavenge"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#ergonomics", 
            "text": "This indicates you are using the adaptive size policy,  -XX:+UseAdaptiveSizePolicy  and is\non by default for recent versions, with the parallel collector ( -XX:+UseParallelGC ). For\nmore details see  The Why of GC Ergonomics .", 
            "title": "Ergonomics"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#g1_evacuation_pause", 
            "text": "An evacuation pause is the most common young gen cause for G1 and indicates that it is copying\nlive objects from one set of regions, young and sometimes young + old, to another set of\nregions. For more details see  Understanding G1 GC Logs .", 
            "title": "G1_Evacuation_Pause"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#g1_humongous_allocation", 
            "text": "A humongous allocation is one where the size is greater than 50% of the G1 region size. Before\na humongous allocation the jvm checks if it should do a routine evacuation pause  without regard to the actual allocation size, but if\ntriggered due to this check the cause will be listed as humongous allocation. This cause is\nalso used for any collections used to free up enough space for the allocation.", 
            "title": "G1_Humongous_Allocation"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#last_ditch_collection", 
            "text": "For perm gen (java 7 or earlier) and metaspace (java 8+) a last ditch collection will be\ntriggered if an allocation fails and the memory pool cannot be expanded.", 
            "title": "Last_ditch_collection"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#illegal_value_-last_gc_cause-_illegal_value", 
            "text": "Included for completeness, but you should never see this value.", 
            "title": "ILLEGAL_VALUE_-last_gc_cause-_ILLEGAL_VALUE"
        }, 
        {
            "location": "/ext/jvm-gc-causes/#unknown_gccause", 
            "text": "Included for completeness, but you should never see this value.", 
            "title": "unknown_GCCause"
        }, 
        {
            "location": "/ext/jvm-memory-pools/", 
            "text": "Memory Pools\n\n\nUses the \nMemoryPoolMXBean\n\nprovided by the JDK to monitor the sizes of java memory spaces such as perm gen, eden, old\ngen, etc. \n\n\nGetting Started\n\n\nTo get information about memory pools in spectator just setup registration of standard MXBeans.\nNote, if you are building an app at Netflix this should happen automatically via the normal\nplatform initialization.\n\n\nimport com.netflix.spectator.api.Spectator;\nimport com.netflix.spectator.jvm.Jmx;\n\nJmx.registerStandardMXBeans(Spectator.registry());\n\n\n\n\nMetrics\n\n\njvm.memory.used\n\n\nGauge reporting the current amount of memory used. For the young and old gen pools this\nmetric will typically have a sawtooth pattern. For alerting or detecting memory pressure\nthe \nlive data size\n\nis probably a better option.\n\n\nUnit:\n bytes\n\n\nDimensions:\n\nsee \nmetric dimensions\n\n\njvm.memory.committed\n\n\nGauge reporting the current amount of memory committed. From the\n\njavadocs\n,\ncommitted is:\n\n\n\n\nThe amount of memory (in bytes) that is guaranteed to be available for use by the Java\nvirtual machine. The amount of committed memory may change over time (increase or decrease).\nThe Java virtual machine may release memory to the system and committed could be less than\ninit. committed will always be greater than or equal to used.\n\n\n\n\nUnit:\n bytes \n\n\nDimensions:\n\nsee \nmetric dimensions\n\n\njvm.memory.max\n\n\nGauge reporting the max amount of memory that can be used. From the\n\njavadocs\n,\nmax is:\n\n\n\n\nThe maximum amount of memory (in bytes) that can be used for memory management. Its value\nmay be undefined. The maximum amount of memory may change over time if defined. The amount\nof used and committed memory will always be less than or equal to max if max is defined. A\nmemory allocation may fail if it attempts to increase the used memory such that\n\nused \n committed\n even if \nused \n= max\n would still be true (for example, when the\nsystem is low on virtual memory).\n\n\n\n\nUnit:\n bytes \n\n\nDimensions:\n\nsee \nmetric dimensions\n\n\nMetric Dimensions\n\n\nAll memory metrics have the following dimensions:\n\n\n\n\nid\n: name of the memory pool being reported. The names of the pools vary depending on the\n  garbage collector algorithm being used.\n\n\nmemtype\n: type of memory. It has two possible values: \nHEAP\n and \nNON_HEAP\n. For more\n  information see the javadocs for \nMemoryType\n.", 
            "title": "Memory Pools"
        }, 
        {
            "location": "/ext/jvm-memory-pools/#memory-pools", 
            "text": "Uses the  MemoryPoolMXBean \nprovided by the JDK to monitor the sizes of java memory spaces such as perm gen, eden, old\ngen, etc.", 
            "title": "Memory Pools"
        }, 
        {
            "location": "/ext/jvm-memory-pools/#getting-started", 
            "text": "To get information about memory pools in spectator just setup registration of standard MXBeans.\nNote, if you are building an app at Netflix this should happen automatically via the normal\nplatform initialization.  import com.netflix.spectator.api.Spectator;\nimport com.netflix.spectator.jvm.Jmx;\n\nJmx.registerStandardMXBeans(Spectator.registry());", 
            "title": "Getting Started"
        }, 
        {
            "location": "/ext/jvm-memory-pools/#metrics", 
            "text": "", 
            "title": "Metrics"
        }, 
        {
            "location": "/ext/jvm-memory-pools/#jvmmemoryused", 
            "text": "Gauge reporting the current amount of memory used. For the young and old gen pools this\nmetric will typically have a sawtooth pattern. For alerting or detecting memory pressure\nthe  live data size \nis probably a better option.  Unit:  bytes  Dimensions: \nsee  metric dimensions", 
            "title": "jvm.memory.used"
        }, 
        {
            "location": "/ext/jvm-memory-pools/#jvmmemorycommitted", 
            "text": "Gauge reporting the current amount of memory committed. From the javadocs ,\ncommitted is:   The amount of memory (in bytes) that is guaranteed to be available for use by the Java\nvirtual machine. The amount of committed memory may change over time (increase or decrease).\nThe Java virtual machine may release memory to the system and committed could be less than\ninit. committed will always be greater than or equal to used.   Unit:  bytes   Dimensions: \nsee  metric dimensions", 
            "title": "jvm.memory.committed"
        }, 
        {
            "location": "/ext/jvm-memory-pools/#jvmmemorymax", 
            "text": "Gauge reporting the max amount of memory that can be used. From the javadocs ,\nmax is:   The maximum amount of memory (in bytes) that can be used for memory management. Its value\nmay be undefined. The maximum amount of memory may change over time if defined. The amount\nof used and committed memory will always be less than or equal to max if max is defined. A\nmemory allocation may fail if it attempts to increase the used memory such that used   committed  even if  used  = max  would still be true (for example, when the\nsystem is low on virtual memory).   Unit:  bytes   Dimensions: \nsee  metric dimensions", 
            "title": "jvm.memory.max"
        }, 
        {
            "location": "/ext/jvm-memory-pools/#metric-dimensions", 
            "text": "All memory metrics have the following dimensions:   id : name of the memory pool being reported. The names of the pools vary depending on the\n  garbage collector algorithm being used.  memtype : type of memory. It has two possible values:  HEAP  and  NON_HEAP . For more\n  information see the javadocs for  MemoryType .", 
            "title": "Metric Dimensions"
        }, 
        {
            "location": "/ext/log4j2/", 
            "text": "Log4j2 Appender\n\n\nCustom appender for \nlog4j2\n to track the number of\nlog messages reported. \n\n\nGetting Started\n\n\nTo use it simply add a dependency:\n\n\ncom.netflix.spectator:spectator-ext-log4j2:0.38.0\n\n\n\n\nThen in your application initialization:\n\n\nRegistry registry = ...\nSpectatorAppender.addToRootLogger(\n    registry,             // Registry to use\n    \nspectator\n,          // Name for the appender\n    false);               // Should stack traces be ignored?\n\n\n\n\nThis will add the appender to the root logger and register a listener so it will get\nre-added if the configuration changes. You can also use the appender by specifying it\nin the log4j2 configuration, but this will cause some of the loggers in Spectator to get\ncreated before log4j is properly initialized and result in some lost log messages. With\nthat caveat in mind, if you need the additional flexibility of using the configuration then\nspecify the \nSpectator\n appender:\n\n\n?xml version=\n1.0\n encoding=\nUTF-8\n?\n\n\nConfiguration monitorInterval=\n5\n status=\nwarn\n\n  \nAppenders\n\n    \nSpectator name=\nroot\n/\n\n  \n/Appenders\n\n  \nLoggers\n\n    \nRoot level=\ndebug\n\n      \nAppenderRef ref=\nroot\n/\n\n    \n/Root\n\n  \n/Loggers\n\n\n/Configuration\n\n\n\n\n\nMetrics\n\n\nlog4j.numMessages\n\n\nCounters showing the number of messages that have been passed to the appender.\n\n\nUnit:\n messages/second\n\n\nDimensions:\n\n\n\n\nappender\n: name of the spectator appender.\n\n\nloglevel\n: standard log level of the events.\n\n\n\n\nlog4j.numStackTraces\n\n\nCounter for the number of messages with stack traces written to the logs. This will only be\ncollected if the \nignoreExceptions\n flag is set to false for the appender.\n\n\nUnit:\n messages/second\n\n\nDimensions:\n\n\n\n\nappender\n: name of the spectator appender.\n\n\nloglevel\n: standard log level of the events.\n\n\nexception\n: simple class name for the exception that was thrown.\n\n\nfile\n: file name for where the exception was thrown.", 
            "title": "Log4j2 Appender"
        }, 
        {
            "location": "/ext/log4j2/#log4j2-appender", 
            "text": "Custom appender for  log4j2  to track the number of\nlog messages reported.", 
            "title": "Log4j2 Appender"
        }, 
        {
            "location": "/ext/log4j2/#getting-started", 
            "text": "To use it simply add a dependency:  com.netflix.spectator:spectator-ext-log4j2:0.38.0  Then in your application initialization:  Registry registry = ...\nSpectatorAppender.addToRootLogger(\n    registry,             // Registry to use\n     spectator ,          // Name for the appender\n    false);               // Should stack traces be ignored?  This will add the appender to the root logger and register a listener so it will get\nre-added if the configuration changes. You can also use the appender by specifying it\nin the log4j2 configuration, but this will cause some of the loggers in Spectator to get\ncreated before log4j is properly initialized and result in some lost log messages. With\nthat caveat in mind, if you need the additional flexibility of using the configuration then\nspecify the  Spectator  appender:  ?xml version= 1.0  encoding= UTF-8 ?  Configuration monitorInterval= 5  status= warn \n   Appenders \n     Spectator name= root / \n   /Appenders \n   Loggers \n     Root level= debug \n       AppenderRef ref= root / \n     /Root \n   /Loggers  /Configuration", 
            "title": "Getting Started"
        }, 
        {
            "location": "/ext/log4j2/#metrics", 
            "text": "", 
            "title": "Metrics"
        }, 
        {
            "location": "/ext/log4j2/#log4jnummessages", 
            "text": "Counters showing the number of messages that have been passed to the appender.  Unit:  messages/second  Dimensions:   appender : name of the spectator appender.  loglevel : standard log level of the events.", 
            "title": "log4j.numMessages"
        }, 
        {
            "location": "/ext/log4j2/#log4jnumstacktraces", 
            "text": "Counter for the number of messages with stack traces written to the logs. This will only be\ncollected if the  ignoreExceptions  flag is set to false for the appender.  Unit:  messages/second  Dimensions:   appender : name of the spectator appender.  loglevel : standard log level of the events.  exception : simple class name for the exception that was thrown.  file : file name for where the exception was thrown.", 
            "title": "log4j.numStackTraces"
        }, 
        {
            "location": "/registry/metrics3/", 
            "text": "Metrics3 Registry\n\n\nRegistry that uses \nmetrics3\n as the\nunderlying implementation. To use the metrics registry, add a dependency on the\n\nspectator-reg-metrics3\n library. For gradle:\n\n\ncom.netflix.spectator:spectator-reg-metrics3:0.38.0\n\n\n\n\nThen when initializing the application, use the \nMetricsRegistry\n. For more\ninformation see the \nmetrics3 example\n.", 
            "title": "Metrics3"
        }, 
        {
            "location": "/registry/metrics3/#metrics3-registry", 
            "text": "Registry that uses  metrics3  as the\nunderlying implementation. To use the metrics registry, add a dependency on the spectator-reg-metrics3  library. For gradle:  com.netflix.spectator:spectator-reg-metrics3:0.38.0  Then when initializing the application, use the  MetricsRegistry . For more\ninformation see the  metrics3 example .", 
            "title": "Metrics3 Registry"
        }, 
        {
            "location": "/registry/servo/", 
            "text": "Servo Registry\n\n\nRegistry that uses \nservo\n as the underlying\nimplementation. To use the servo registry, add a dependency on the\n\nspectator-reg-servo\n library. For gradle:\n\n\ncom.netflix.spectator:spectator-reg-servo:0.38.0\n\n\n\n\nThen when initializing the application, use the \nServoRegistry\n. If using guice\nthen that would look like:\n\n\nInjector injector = Guice.createInjector(new AbstractModule() {\n    @Override protected void configure() {\n    }\n\n    @Provides\n    @Singleton\n    private Registry providesRegistry() {\n      return new ServoRegistry();\n    }\n  });\n\n\n\n\nFor more information see the \nservo example\n.\nNote if running internally at Netflix see the [[Netflix Integration]] docs\ninstead.", 
            "title": "Servo"
        }, 
        {
            "location": "/registry/servo/#servo-registry", 
            "text": "Registry that uses  servo  as the underlying\nimplementation. To use the servo registry, add a dependency on the spectator-reg-servo  library. For gradle:  com.netflix.spectator:spectator-reg-servo:0.38.0  Then when initializing the application, use the  ServoRegistry . If using guice\nthen that would look like:  Injector injector = Guice.createInjector(new AbstractModule() {\n    @Override protected void configure() {\n    }\n\n    @Provides\n    @Singleton\n    private Registry providesRegistry() {\n      return new ServoRegistry();\n    }\n  });  For more information see the  servo example .\nNote if running internally at Netflix see the [[Netflix Integration]] docs\ninstead.", 
            "title": "Servo Registry"
        }, 
        {
            "location": "/registry/tdigest/", 
            "text": "T-Digest Registry\n\n\n\n\nWarning\n\n\nDeprecated, use PercentileTimer or PercentileDistributionSummary instead.\n\n\n\n\nThe TDigest registry is used for collecting dimensional percentile data and reporting to\nbackends. This is currently an experiment and not ready for general use. Current instructions\nassume it is being used \ninternally at Netflix\n.\n\n\nGetting Started\n\n\nTo use it simply add a dependency:\n\n\ncom.netflix.spectator:spectator-reg-tdigest:0.38.0\n\n\n\n\nAdd the \nTDigestModule\n to the set of modules used with guice:\n\n\nInjector injector = Guice.createInjector(\n  new SpectatorModule(),\n  new TDigestModule(),\n  ...);\n\n\n\n\nThen just inject the \nTDigestRegistry\n:\n\n\npublic class Foo {\n  private final Registry registry;\n\n  public Foo(TDigestRegistry digestRegistry) {\n    registry = digestRegistry;\n  }\n\n  public void doSomething() {\n    registry.timer(\nfoo.doSomething\n).record(() -\n {\n      ... something ...\n    });\n  }\n}\n\n\n\n\nTimers and distribution summaries accessed via the \nTDigestRegistry\n will be recorded to both\nthe main registry and the digest registry.\n\n\nRecommendations\n\n\n\n\nUse digests sparingly. The digest structure will take more memory locally and have additional\noverhead compared to typical implementations. \n\n\n\n\nTesting\n\n\nFor unit tests use the \nTDigestTestModule\n to get an injectable \nTDigestRegistry\n. Then follow\nthe \nnormal testing instructions\n. Example:\n\n\n@RunWith(JUnit4.class)\npublic class FooTest {\n\n  @Test\n  public void doSomething() throws Exception {\n    Injector injector = Guice.createInjector(TDigestTestModule.create());\n    injector.getInstance(Foo.class).doSomething();\n\n    final TDigestRegistry r = injector.getInstance(TDigestRegistry.class);\n    Assert.assertEquals(1, r.timer(\nfoo\n).count());\n    Assert.assertEquals(42, r.timer(\nfoo\n).totalTime());\n  }\n\n  private static class Foo {\n    private final Timer t;\n\n    @Inject\n    Foo(TDigestRegistry registry) {\n      t = registry.timer(\nfoo\n);\n    }\n\n    void doSomething() {\n      t.record(42, TimeUnit.NANOSECONDS);\n    }\n  }\n}\n\n\n\n\nKnown Issues\n\n\n\n\nOnly reports to kinesis for now. This will be changed after the configuration format is\n  figured out.\n\n\nThere is still some debate about whether to control the access via the code and injecting\n  the specific registry or using configuration. \n\n\nThere is work in progress on having a fixed limit to protect both the local client and\n  backends. If the limit is reached rollup policies would get triggered to gracefully degrade.\n\n\nCan we support high level digest along with basic timer with more dimensionality. Still\n  investigating pending the outcome of previous bullets.\n\n\nNot yet supported via sidecar endpoints.", 
            "title": "TDigest"
        }, 
        {
            "location": "/registry/tdigest/#t-digest-registry", 
            "text": "Warning  Deprecated, use PercentileTimer or PercentileDistributionSummary instead.   The TDigest registry is used for collecting dimensional percentile data and reporting to\nbackends. This is currently an experiment and not ready for general use. Current instructions\nassume it is being used  internally at Netflix .", 
            "title": "T-Digest Registry"
        }, 
        {
            "location": "/registry/tdigest/#getting-started", 
            "text": "To use it simply add a dependency:  com.netflix.spectator:spectator-reg-tdigest:0.38.0  Add the  TDigestModule  to the set of modules used with guice:  Injector injector = Guice.createInjector(\n  new SpectatorModule(),\n  new TDigestModule(),\n  ...);  Then just inject the  TDigestRegistry :  public class Foo {\n  private final Registry registry;\n\n  public Foo(TDigestRegistry digestRegistry) {\n    registry = digestRegistry;\n  }\n\n  public void doSomething() {\n    registry.timer( foo.doSomething ).record(() -  {\n      ... something ...\n    });\n  }\n}  Timers and distribution summaries accessed via the  TDigestRegistry  will be recorded to both\nthe main registry and the digest registry.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/registry/tdigest/#recommendations", 
            "text": "Use digests sparingly. The digest structure will take more memory locally and have additional\noverhead compared to typical implementations.", 
            "title": "Recommendations"
        }, 
        {
            "location": "/registry/tdigest/#testing", 
            "text": "For unit tests use the  TDigestTestModule  to get an injectable  TDigestRegistry . Then follow\nthe  normal testing instructions . Example:  @RunWith(JUnit4.class)\npublic class FooTest {\n\n  @Test\n  public void doSomething() throws Exception {\n    Injector injector = Guice.createInjector(TDigestTestModule.create());\n    injector.getInstance(Foo.class).doSomething();\n\n    final TDigestRegistry r = injector.getInstance(TDigestRegistry.class);\n    Assert.assertEquals(1, r.timer( foo ).count());\n    Assert.assertEquals(42, r.timer( foo ).totalTime());\n  }\n\n  private static class Foo {\n    private final Timer t;\n\n    @Inject\n    Foo(TDigestRegistry registry) {\n      t = registry.timer( foo );\n    }\n\n    void doSomething() {\n      t.record(42, TimeUnit.NANOSECONDS);\n    }\n  }\n}", 
            "title": "Testing"
        }, 
        {
            "location": "/registry/tdigest/#known-issues", 
            "text": "Only reports to kinesis for now. This will be changed after the configuration format is\n  figured out.  There is still some debate about whether to control the access via the code and injecting\n  the specific registry or using configuration.   There is work in progress on having a fixed limit to protect both the local client and\n  backends. If the limit is reached rollup policies would get triggered to gracefully degrade.  Can we support high level digest along with basic timer with more dimensionality. Still\n  investigating pending the outcome of previous bullets.  Not yet supported via sidecar endpoints.", 
            "title": "Known Issues"
        }, 
        {
            "location": "/reports/", 
            "text": "Build Reports\n\n\nThese are automated reports generated from the build.\n\n\nspectator-api\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-ext-aws\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-ext-gc\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-ext-jvm\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-ext-log4j2\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-ext-sandbox\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-ext-spark\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-nflx\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-nflx-plugin\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-reg-metrics3\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-reg-servo\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs\n\n\n\n\nspectator-reg-tdigest\n\n\n\n\nJavaDoc\n\n\nTests\n\n\nCoverage\n\n\nPMD\n\n\nFindBugs", 
            "title": "Build Reports"
        }, 
        {
            "location": "/reports/#build-reports", 
            "text": "These are automated reports generated from the build.", 
            "title": "Build Reports"
        }, 
        {
            "location": "/reports/#spectator-api", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-api"
        }, 
        {
            "location": "/reports/#spectator-ext-aws", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-ext-aws"
        }, 
        {
            "location": "/reports/#spectator-ext-gc", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-ext-gc"
        }, 
        {
            "location": "/reports/#spectator-ext-jvm", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-ext-jvm"
        }, 
        {
            "location": "/reports/#spectator-ext-log4j2", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-ext-log4j2"
        }, 
        {
            "location": "/reports/#spectator-ext-sandbox", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-ext-sandbox"
        }, 
        {
            "location": "/reports/#spectator-ext-spark", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-ext-spark"
        }, 
        {
            "location": "/reports/#spectator-nflx", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-nflx"
        }, 
        {
            "location": "/reports/#spectator-nflx-plugin", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-nflx-plugin"
        }, 
        {
            "location": "/reports/#spectator-reg-metrics3", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-reg-metrics3"
        }, 
        {
            "location": "/reports/#spectator-reg-servo", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-reg-servo"
        }, 
        {
            "location": "/reports/#spectator-reg-tdigest", 
            "text": "JavaDoc  Tests  Coverage  PMD  FindBugs", 
            "title": "spectator-reg-tdigest"
        }
    ]
}
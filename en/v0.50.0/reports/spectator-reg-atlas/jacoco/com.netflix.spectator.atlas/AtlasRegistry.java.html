<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AtlasRegistry.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spectator-reg-atlas</a> &gt; <a href="index.source.html" class="el_package">com.netflix.spectator.atlas</a> &gt; <span class="el_source">AtlasRegistry.java</span></div><h1>AtlasRegistry.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2014-2016 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.netflix.spectator.atlas;

import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.fasterxml.jackson.dataformat.smile.SmileFactory;
import com.netflix.spectator.api.AbstractRegistry;
import com.netflix.spectator.api.Clock;
import com.netflix.spectator.api.Counter;
import com.netflix.spectator.api.DistributionSummary;
import com.netflix.spectator.api.Gauge;
import com.netflix.spectator.api.Id;
import com.netflix.spectator.api.Measurement;
import com.netflix.spectator.api.Timer;
import com.netflix.spectator.impl.Scheduler;
import com.netflix.spectator.sandbox.HttpClient;
import com.netflix.spectator.sandbox.HttpResponse;

import java.net.URI;
import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

/**
 * Registry for reporting metrics to Atlas.
 */
public final class AtlasRegistry extends AbstractRegistry {

  private static final String CLOCK_SKEW_TIMER = &quot;spectator.atlas.clockSkew&quot;;

  private final Clock clock;

  private final boolean enabled;
  private final Duration step;
  private final long stepMillis;
  private final URI uri;

  private final boolean lwcEnabled;
  private final Duration configRefreshFrequency;
  private final URI configUri;
  private final URI evalUri;

  private final int connectTimeout;
  private final int readTimeout;
  private final int batchSize;
  private final int numThreads;
  private final Map&lt;String, String&gt; commonTags;

  private final ObjectMapper jsonMapper;
  private final ObjectMapper smileMapper;

  private Scheduler scheduler;

  private volatile List&lt;Subscription&gt; subscriptions;

  /** Create a new instance. */
  public AtlasRegistry(Clock clock, AtlasConfig config) {
<span class="fc" id="L79">    super(new StepClock(clock, config.step().toMillis()), config);</span>
<span class="fc" id="L80">    this.clock = clock;</span>

<span class="fc" id="L82">    this.enabled = config.enabled();</span>
<span class="fc" id="L83">    this.step = config.step();</span>
<span class="fc" id="L84">    this.stepMillis = step.toMillis();</span>
<span class="fc" id="L85">    this.uri = URI.create(config.uri());</span>

<span class="fc" id="L87">    this.lwcEnabled = config.lwcEnabled();</span>
<span class="fc" id="L88">    this.configRefreshFrequency = config.configRefreshFrequency();</span>
<span class="fc" id="L89">    this.configUri = URI.create(config.configUri());</span>
<span class="fc" id="L90">    this.evalUri = URI.create(config.evalUri());</span>

<span class="fc" id="L92">    this.connectTimeout = (int) config.connectTimeout().toMillis();</span>
<span class="fc" id="L93">    this.readTimeout = (int) config.readTimeout().toMillis();</span>
<span class="fc" id="L94">    this.batchSize = config.batchSize();</span>
<span class="fc" id="L95">    this.numThreads = config.numThreads();</span>
<span class="fc" id="L96">    this.commonTags = new TreeMap&lt;&gt;(config.commonTags());</span>

<span class="fc" id="L98">    SimpleModule module = new SimpleModule()</span>
<span class="fc" id="L99">        .addSerializer(Measurement.class, new MeasurementSerializer());</span>
<span class="fc" id="L100">    this.jsonMapper = new ObjectMapper(new JsonFactory()).registerModule(module);</span>
<span class="fc" id="L101">    this.smileMapper = new ObjectMapper(new SmileFactory()).registerModule(module);</span>
<span class="fc" id="L102">  }</span>

  /**
   * Start the scheduler to collect metrics data.
   */
  public void start() {
<span class="nc bnc" id="L108" title="All 2 branches missed.">    if (scheduler == null) {</span>
      // Setup main collection for publishing to Atlas
<span class="nc bnc" id="L110" title="All 4 branches missed.">      if (enabled || lwcEnabled) {</span>
<span class="nc" id="L111">        Scheduler.Options options = new Scheduler.Options()</span>
<span class="nc" id="L112">            .withFrequency(Scheduler.Policy.FIXED_RATE_SKIP_IF_LONG, step)</span>
<span class="nc" id="L113">            .withInitialDelay(Duration.ofMillis(getInitialDelay(stepMillis)))</span>
<span class="nc" id="L114">            .withStopOnFailure(false);</span>
<span class="nc" id="L115">        scheduler = new Scheduler(this, &quot;spectator-reg-atlas&quot;, numThreads);</span>
<span class="nc" id="L116">        scheduler.schedule(options, this::collectData);</span>
<span class="nc" id="L117">        logger.info(&quot;started collecting metrics every {} reporting to {}&quot;, step, uri);</span>
<span class="nc" id="L118">        logger.info(&quot;common tags: {}&quot;, commonTags);</span>
<span class="nc" id="L119">      } else {</span>
<span class="nc" id="L120">        logger.info(&quot;publishing is not enabled&quot;);</span>
      }

      // Setup collection for subscriptions
<span class="nc bnc" id="L124" title="All 2 branches missed.">      if (lwcEnabled) {</span>
<span class="nc" id="L125">        Scheduler.Options options = new Scheduler.Options()</span>
<span class="nc" id="L126">            .withFrequency(Scheduler.Policy.FIXED_DELAY, configRefreshFrequency)</span>
<span class="nc" id="L127">            .withStopOnFailure(false);</span>
<span class="nc" id="L128">        scheduler.schedule(options, this::fetchSubscriptions);</span>
<span class="nc" id="L129">      } else {</span>
<span class="nc" id="L130">        logger.info(&quot;subscriptions are not enabled&quot;);</span>
      }
    } else {
<span class="nc" id="L133">      logger.warn(&quot;registry already started, ignoring duplicate request&quot;);</span>
    }
<span class="nc" id="L135">  }</span>

  /**
   * Avoid collecting right on boundaries to minimize transitions on step longs
   * during a collection. Randomly distribute across the middle of the step interval.
   */
  long getInitialDelay(long stepSize) {
<span class="fc" id="L142">    long now = clock.wallTime();</span>
<span class="fc" id="L143">    long stepBoundary = now / stepSize * stepSize;</span>

    // Buffer by 10% of the step interval on either side
<span class="fc" id="L146">    long offset = stepSize / 10;</span>

    // Check if the current delay is within the acceptable range
<span class="fc" id="L149">    long delay = now - stepBoundary;</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">    if (delay &lt; offset) {</span>
<span class="fc" id="L151">      return delay + offset;</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">    } else if (delay &gt; stepSize - offset) {</span>
<span class="fc" id="L153">      return stepSize - offset;</span>
    } else {
<span class="fc" id="L155">      return delay;</span>
    }
  }

  /**
   * Stop the scheduler reporting Atlas data.
   */
  public void stop() {
<span class="nc bnc" id="L163" title="All 2 branches missed.">    if (scheduler != null) {</span>
<span class="nc" id="L164">      scheduler.shutdown();</span>
<span class="nc" id="L165">      scheduler = null;</span>
<span class="nc" id="L166">      logger.info(&quot;stopped collecting metrics every {}ms reporting to {}&quot;, step, uri);</span>
    } else {
<span class="nc" id="L168">      logger.warn(&quot;registry stopped, but was never started&quot;);</span>
    }
<span class="nc" id="L170">  }</span>

  private void collectData() {
    // Send data for any subscriptions
<span class="nc bnc" id="L174" title="All 2 branches missed.">    if (lwcEnabled) {</span>
      try {
<span class="nc" id="L176">        handleSubscriptions();</span>
<span class="nc" id="L177">      } catch (Exception e) {</span>
<span class="nc" id="L178">        logger.warn(&quot;failed to handle subscriptions&quot;, e);</span>
<span class="nc" id="L179">      }</span>
    }

    // Publish to Atlas
<span class="nc bnc" id="L183" title="All 2 branches missed.">    if (enabled) {</span>
      try {
<span class="nc bnc" id="L185" title="All 2 branches missed.">        for (List&lt;Measurement&gt; batch : getBatches()) {</span>
<span class="nc" id="L186">          PublishPayload p = new PublishPayload(commonTags, batch);</span>
<span class="nc" id="L187">          HttpResponse res = HttpClient.DEFAULT.newRequest(&quot;spectator-reg-atlas&quot;, uri)</span>
<span class="nc" id="L188">              .withMethod(&quot;POST&quot;)</span>
<span class="nc" id="L189">              .withConnectTimeout(connectTimeout)</span>
<span class="nc" id="L190">              .withReadTimeout(readTimeout)</span>
<span class="nc" id="L191">              .withContent(&quot;application/x-jackson-smile&quot;, smileMapper.writeValueAsBytes(p))</span>
<span class="nc" id="L192">              .send();</span>
<span class="nc" id="L193">          Instant date = res.dateHeader(&quot;Date&quot;);</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">          recordClockSkew((date == null) ? 0L : date.toEpochMilli());</span>
<span class="nc" id="L195">        }</span>
<span class="nc" id="L196">      } catch (Exception e) {</span>
<span class="nc" id="L197">        logger.warn(&quot;failed to send metrics&quot;, e);</span>
<span class="nc" id="L198">      }</span>
    }
<span class="nc" id="L200">  }</span>

  private void handleSubscriptions() {
<span class="nc" id="L203">    List&lt;Subscription&gt; subs = subscriptions;</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">    if (!subs.isEmpty()) {</span>
<span class="nc" id="L205">      List&lt;TagsValuePair&gt; ms = getMeasurements().stream()</span>
<span class="nc" id="L206">          .map(m -&gt; TagsValuePair.from(commonTags, m))</span>
<span class="nc" id="L207">          .collect(Collectors.toList());</span>
<span class="nc" id="L208">      List&lt;EvalPayload.Metric&gt; metrics = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">      for (Subscription s : subs) {</span>
<span class="nc" id="L210">        DataExpr expr = Parser.parseDataExpr(s.getExpression());</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">        for (TagsValuePair pair : expr.eval(ms)) {</span>
<span class="nc" id="L212">          EvalPayload.Metric m = new EvalPayload.Metric(s.getId(), pair.tags(), pair.value());</span>
<span class="nc" id="L213">          metrics.add(m);</span>
<span class="nc" id="L214">        }</span>
<span class="nc" id="L215">      }</span>
      try {
<span class="nc" id="L217">        String json = jsonMapper.writeValueAsString(new EvalPayload(clock().wallTime(), metrics));</span>
<span class="nc" id="L218">        HttpClient.DEFAULT.newRequest(&quot;spectator-lwc-eval&quot;, evalUri)</span>
<span class="nc" id="L219">            .withMethod(&quot;POST&quot;)</span>
<span class="nc" id="L220">            .withConnectTimeout(connectTimeout)</span>
<span class="nc" id="L221">            .withReadTimeout(readTimeout)</span>
<span class="nc" id="L222">            .withJsonContent(json)</span>
<span class="nc" id="L223">            .send()</span>
<span class="nc" id="L224">            .decompress();</span>
<span class="nc" id="L225">      } catch (Exception e) {</span>
<span class="nc" id="L226">        logger.warn(&quot;failed to send metrics for subscriptions&quot;, e);</span>
<span class="nc" id="L227">      }</span>
    }
<span class="nc" id="L229">  }</span>

  private void fetchSubscriptions() {
    try {
<span class="nc" id="L233">      HttpResponse res = HttpClient.DEFAULT.newRequest(&quot;spectator-lwc-subs&quot;, configUri)</span>
<span class="nc" id="L234">          .withMethod(&quot;GET&quot;)</span>
<span class="nc" id="L235">          .withConnectTimeout(connectTimeout)</span>
<span class="nc" id="L236">          .withReadTimeout(readTimeout)</span>
<span class="nc" id="L237">          .send()</span>
<span class="nc" id="L238">          .decompress();</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">      if (res.status() != 200) {</span>
<span class="nc" id="L240">        logger.warn(&quot;failed to update subscriptions, received status {}&quot;, res.status());</span>
      } else {
<span class="nc" id="L242">        Subscriptions subs = jsonMapper.readValue(res.entity(), Subscriptions.class);</span>
<span class="nc" id="L243">        subscriptions = subs.validated();</span>
      }
<span class="nc" id="L245">    } catch (Exception e) {</span>
<span class="nc" id="L246">      logger.warn(&quot;failed to send metrics&quot;, e);</span>
<span class="nc" id="L247">    }</span>
<span class="nc" id="L248">  }</span>

  /**
   * Record the difference between the date response time and the local time on the server.
   * This is used to get a rough idea of the amount of skew in the environment. Ideally it
   * should be fairly small. The date header will only have seconds so we expect to regularly
   * have differences of up to 1 second. Note, that it is a rough estimate and could be
   * elevated because of unrelated problems like GC or network delays.
   */
  private void recordClockSkew(long responseTimestamp) {
<span class="nc bnc" id="L258" title="All 2 branches missed.">    if (responseTimestamp == 0L) {</span>
<span class="nc" id="L259">      logger.debug(&quot;no date timestamp on response, cannot record skew&quot;);</span>
    } else {
<span class="nc" id="L261">      final long delta = clock.wallTime() - responseTimestamp;</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">      if (delta &gt;= 0L) {</span>
        // Local clock is running fast compared to the server. Note this should also be the
        // common case for if the clocks are in sync as there will be some delay for the server
        // response to reach this node.
<span class="nc" id="L266">        timer(CLOCK_SKEW_TIMER, &quot;id&quot;, &quot;fast&quot;).record(delta, TimeUnit.MILLISECONDS);</span>
      } else {
        // Local clock is running slow compared to the server. This means the response timestamp
        // appears to be after the current time on this node. The timer will ignore negative
        // values so we negate and record it with a different id.
<span class="nc" id="L271">        timer(CLOCK_SKEW_TIMER, &quot;id&quot;, &quot;slow&quot;).record(-delta, TimeUnit.MILLISECONDS);</span>
      }
<span class="nc" id="L273">      logger.debug(&quot;clock skew between client and server: {}ms&quot;, delta);</span>
    }
<span class="nc" id="L275">  }</span>

  /** Get a list of all measurements from the registry. */
  List&lt;Measurement&gt; getMeasurements() {
<span class="fc" id="L279">    return stream()</span>
<span class="fc" id="L280">        .flatMap(m -&gt; StreamSupport.stream(m.measure().spliterator(), false))</span>
<span class="fc" id="L281">        .collect(Collectors.toList());</span>
  }

  /** Get a list of all measurements and break them into batches. */
  List&lt;List&lt;Measurement&gt;&gt; getBatches() {
<span class="fc" id="L286">    List&lt;List&lt;Measurement&gt;&gt; batches = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L287">    List&lt;Measurement&gt; ms = getMeasurements();</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">    for (int i = 0; i &lt; ms.size(); i += batchSize) {</span>
<span class="fc" id="L289">      List&lt;Measurement&gt; batch = ms.subList(i, Math.min(ms.size(), i + batchSize));</span>
<span class="fc" id="L290">      batches.add(batch);</span>
    }
<span class="fc" id="L292">    return batches;</span>
  }

  @Override protected Counter newCounter(Id id) {
<span class="fc" id="L296">    return new AtlasCounter(id, clock, stepMillis);</span>
  }

  @Override protected DistributionSummary newDistributionSummary(Id id) {
<span class="fc" id="L300">    return new AtlasDistributionSummary(id, clock, stepMillis);</span>
  }

  @Override protected Timer newTimer(Id id) {
<span class="fc" id="L304">    return new AtlasTimer(id, clock, stepMillis);</span>
  }

  @Override protected Gauge newGauge(Id id) {
    // Be sure to get StepClock so the measurements will have step aligned
    // timestamps.
<span class="fc" id="L310">    return new AtlasGauge(id, clock());</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>
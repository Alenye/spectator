<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Parser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spectator-reg-atlas</a> &gt; <a href="index.source.html" class="el_package">com.netflix.spectator.atlas</a> &gt; <span class="el_source">Parser.java</span></div><h1>Parser.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2014-2016 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.netflix.spectator.atlas;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;
import java.util.TreeSet;
import java.util.regex.Pattern;

/**
 * Parses an Atlas data or query expression.
 */
final class Parser {

<span class="nc" id="L30">  private Parser() {</span>
<span class="nc" id="L31">  }</span>

  /**
   * Parse an &lt;a href=&quot;https://github.com/Netflix/atlas/wiki/Reference-data&quot;&gt;Atlas data
   * expression&lt;/a&gt;.
   */
  static DataExpr parseDataExpr(String expr) {
<span class="fc" id="L38">    return (DataExpr) parse(expr);</span>
  }

  /**
   * Parse an &lt;a href=&quot;https://github.com/Netflix/atlas/wiki/Reference-query&quot;&gt;Atlas query
   * expression&lt;/a&gt;.
   */
  static Query parseQuery(String expr) {
<span class="fc" id="L46">    return (Query) parse(expr);</span>
  }

  @SuppressWarnings({&quot;unchecked&quot;, &quot;PMD&quot;})
  private static Object parse(String expr) {
    DataExpr.AggregateFunction af;
    Query q, q1, q2;
    String k, v;
<span class="fc" id="L54">    List&lt;String&gt; vs = null;</span>
<span class="fc" id="L55">    String[] parts = expr.split(&quot;,&quot;);</span>
<span class="fc" id="L56">    Deque&lt;Object&gt; stack = new ArrayDeque&lt;&gt;(parts.length);</span>
<span class="fc bfc" id="L57" title="All 2 branches covered.">    for (String p : parts) {</span>
<span class="fc" id="L58">      String token = p.trim();</span>
<span class="pc bpc" id="L59" title="1 of 2 branches missed.">      if (token.isEmpty()) {</span>
<span class="nc" id="L60">        continue;</span>
      }
<span class="fc bfc" id="L62" title="All 4 branches covered.">      if (vs != null &amp;&amp; !&quot;)&quot;.equals(token)) {</span>
<span class="fc" id="L63">        vs.add(token);</span>
<span class="fc" id="L64">        continue;</span>
      }
<span class="pc bpc" id="L66" title="24 of 98 branches missed.">      switch (token) {</span>
        case &quot;(&quot;:
<span class="fc" id="L68">          vs = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L69">          break;</span>
        case &quot;)&quot;:
<span class="fc" id="L71">          stack.push(vs);</span>
<span class="fc" id="L72">          vs = null;</span>
<span class="fc" id="L73">          break;</span>
        case &quot;:true&quot;:
<span class="fc" id="L75">          stack.push(Query.TRUE);</span>
<span class="fc" id="L76">          break;</span>
        case &quot;:false&quot;:
<span class="fc" id="L78">          stack.push(Query.FALSE);</span>
<span class="fc" id="L79">          break;</span>
        case &quot;:and&quot;:
<span class="fc" id="L81">          q2 = (Query) stack.pop();</span>
<span class="fc" id="L82">          q1 = (Query) stack.pop();</span>
<span class="fc" id="L83">          stack.push(new Query.And(q1, q2));</span>
<span class="fc" id="L84">          break;</span>
        case &quot;:or&quot;:
<span class="fc" id="L86">          q2 = (Query) stack.pop();</span>
<span class="fc" id="L87">          q1 = (Query) stack.pop();</span>
<span class="fc" id="L88">          stack.push(new Query.Or(q1, q2));</span>
<span class="fc" id="L89">          break;</span>
        case &quot;:not&quot;:
<span class="fc" id="L91">          q = (Query) stack.pop();</span>
<span class="fc" id="L92">          stack.push(new Query.Not(q));</span>
<span class="fc" id="L93">          break;</span>
        case &quot;:has&quot;:
<span class="fc" id="L95">          k = (String) stack.pop();</span>
<span class="fc" id="L96">          stack.push(new Query.Has(k));</span>
<span class="fc" id="L97">          break;</span>
        case &quot;:eq&quot;:
<span class="fc" id="L99">          v = (String) stack.pop();</span>
<span class="fc" id="L100">          k = (String) stack.pop();</span>
<span class="fc" id="L101">          stack.push(new Query.Equal(k, v));</span>
<span class="fc" id="L102">          break;</span>
        case &quot;:in&quot;:
<span class="fc" id="L104">          vs = (List&lt;String&gt;) stack.pop();</span>
<span class="fc" id="L105">          k = (String) stack.pop();</span>
<span class="fc" id="L106">          stack.push(new Query.In(k, new TreeSet&lt;&gt;(vs)));</span>
<span class="fc" id="L107">          break;</span>
        case &quot;:lt&quot;:
<span class="fc" id="L109">          v = (String) stack.pop();</span>
<span class="fc" id="L110">          k = (String) stack.pop();</span>
<span class="fc" id="L111">          stack.push(new Query.LessThan(k, v));</span>
<span class="fc" id="L112">          break;</span>
        case &quot;:le&quot;:
<span class="fc" id="L114">          v = (String) stack.pop();</span>
<span class="fc" id="L115">          k = (String) stack.pop();</span>
<span class="fc" id="L116">          stack.push(new Query.LessThanEqual(k, v));</span>
<span class="fc" id="L117">          break;</span>
        case &quot;:gt&quot;:
<span class="fc" id="L119">          v = (String) stack.pop();</span>
<span class="fc" id="L120">          k = (String) stack.pop();</span>
<span class="fc" id="L121">          stack.push(new Query.GreaterThan(k, v));</span>
<span class="fc" id="L122">          break;</span>
        case &quot;:ge&quot;:
<span class="fc" id="L124">          v = (String) stack.pop();</span>
<span class="fc" id="L125">          k = (String) stack.pop();</span>
<span class="fc" id="L126">          stack.push(new Query.GreaterThanEqual(k, v));</span>
<span class="fc" id="L127">          break;</span>
        case &quot;:re&quot;:
<span class="fc" id="L129">          v = (String) stack.pop();</span>
<span class="fc" id="L130">          k = (String) stack.pop();</span>
<span class="fc" id="L131">          stack.push(new Query.Regex(k, v));</span>
<span class="fc" id="L132">          break;</span>
        case &quot;:reic&quot;:
<span class="fc" id="L134">          v = (String) stack.pop();</span>
<span class="fc" id="L135">          k = (String) stack.pop();</span>
<span class="fc" id="L136">          stack.push(new Query.Regex(k, v, Pattern.CASE_INSENSITIVE, &quot;:reic&quot;));</span>
<span class="fc" id="L137">          break;</span>
        case &quot;:all&quot;:
<span class="fc" id="L139">          q = (Query) stack.pop();</span>
<span class="fc" id="L140">          stack.push(new DataExpr.All(q));</span>
<span class="fc" id="L141">          break;</span>
        case &quot;:sum&quot;:
<span class="fc" id="L143">          q = (Query) stack.pop();</span>
<span class="fc" id="L144">          stack.push(new DataExpr.Sum(q));</span>
<span class="fc" id="L145">          break;</span>
        case &quot;:min&quot;:
<span class="fc" id="L147">          q = (Query) stack.pop();</span>
<span class="fc" id="L148">          stack.push(new DataExpr.Min(q));</span>
<span class="fc" id="L149">          break;</span>
        case &quot;:max&quot;:
<span class="fc" id="L151">          q = (Query) stack.pop();</span>
<span class="fc" id="L152">          stack.push(new DataExpr.Max(q));</span>
<span class="fc" id="L153">          break;</span>
        case &quot;:count&quot;:
<span class="fc" id="L155">          q = (Query) stack.pop();</span>
<span class="fc" id="L156">          stack.push(new DataExpr.Count(q));</span>
<span class="fc" id="L157">          break;</span>
        case &quot;:by&quot;:
<span class="fc" id="L159">          vs = (List&lt;String&gt;) stack.pop();</span>
<span class="fc" id="L160">          af = (DataExpr.AggregateFunction) stack.pop();</span>
<span class="fc" id="L161">          stack.push(new DataExpr.GroupBy(af, vs));</span>
<span class="fc" id="L162">          break;</span>
        case &quot;:rollup-drop&quot;:
<span class="fc" id="L164">          vs = (List&lt;String&gt;) stack.pop();</span>
<span class="fc" id="L165">          af = (DataExpr.AggregateFunction) stack.pop();</span>
<span class="fc" id="L166">          stack.push(new DataExpr.DropRollup(af, vs));</span>
<span class="fc" id="L167">          break;</span>
        case &quot;:rollup-keep&quot;:
<span class="fc" id="L169">          vs = (List&lt;String&gt;) stack.pop();</span>
<span class="fc" id="L170">          af = (DataExpr.AggregateFunction) stack.pop();</span>
<span class="fc" id="L171">          stack.push(new DataExpr.KeepRollup(af, vs));</span>
<span class="fc" id="L172">          break;</span>
        default:
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">          if (token.startsWith(&quot;:&quot;)) {</span>
<span class="nc" id="L175">            throw new IllegalArgumentException(&quot;unknown word '&quot; + token + &quot;'&quot;);</span>
          }
<span class="fc" id="L177">          stack.push(token);</span>
          break;
      }
    }
<span class="fc" id="L181">    Object obj = stack.pop();</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">    if (!stack.isEmpty()) {</span>
<span class="nc" id="L183">      throw new IllegalArgumentException(&quot;too many items remaining on stack: &quot; + stack);</span>
    }
<span class="fc" id="L185">    return obj;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>